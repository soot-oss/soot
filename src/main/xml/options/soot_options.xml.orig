<?xml-stylesheet type="text/xsl" href="soot_options.xsl"  ?>
<options>
    <intro>
        <p>
            The descriptions of Soot options talk about three categories of
            classes: argument classes, application classes, and library classes.
        </p>
        <p>
            <var>Argument classes</var>
            are those you specify explicitly to
            Soot. When you use Soot's command line interface, argument
            classes are those classes which are either listed explicitly on
            the command line or found in a directory specified with the
            <tt>-process-dir</tt>
            option. When you use the Soot's Eclipse
            plug-in, argument classes are those which you selected before
            starting Soot from the Navigator popup menu, or all classes in
            the current project if you started Soot from the Project
            menu.
        </p>
        <p>
            <var>Application classes</var>
            are classes that Soot analyzes,
            transforms, and turns into output files.
        </p>
        <p>
            <var>Library classes</var>
            are classes which are referred to,
            directly or indirectly, by the application classes, but which are
            not themselves application classes. Soot resolves these classes
            and reads <tt>.class</tt> or <tt>.jimple</tt> source files for
            them, but it does not perform transformations on library classes
            or write output files for them.
        </p>
        <p>
            All argument classes are necessarily application classes. When
            Soot <emph>is not</emph> in ``application mode'', argument
            classes are the only application classes; other classes
            referenced from the argument classes become library classes.
        </p>
        <p>
            When Soot <emph>is</emph> in application mode, every class
            referenced from the argument classes, directly or indirectly, is
            also an application class, unless its package name indicates that
            it is part of the standard Java runtime system.
        </p>
        <p>
            Users may fine-tune the designation of application and library
            classes using the Application Mode Options.
        </p>
        <p>
            Here is a simple example to clarify things. Suppose your program
            consists of three class files generated from the following
            source:
            <pre>
                // UI.java
                interface UI {
                public void display(String msg);
                }

                // HelloWorld.java
                class HelloWorld {
                public static void main(String[] arg) {
                UI ui = new TextUI();
                ui.display("Hello World");
                }
                }

                // TextUI.java
                import java.io.*;
                class TextUI implements UI {
                public void display(String msg) {
                System.out.println(msg);
                }
                }
            </pre>
        </p>
        <p>
            If you run
            <pre>
                java soot.Main HelloWorld
            </pre>
            <tt>HelloWorld</tt>
            is the only argument class and the only
            application class.  <tt>UI</tt> and <tt>TextUI</tt> are library
            classes, along with <tt>java.lang.System</tt>,
            <tt>java.lang.String</tt>, <tt>java.io.PrintStream</tt>, and a
            host of other classes from the Java runtime system that get
            dragged in indirectly by the references to <tt>String</tt> and
            <tt>System.out</tt>.
        </p>
        <p>
            If you run
            <pre>
                java soot.Main --app HelloWorld
            </pre>
            <tt>HelloWorld</tt>
            remains the
            only argument class, but the application classes include
            <tt>UI</tt>
            and <tt>TextUI</tt> as well as <tt>HelloWorld</tt>.
            <tt>java.lang.System</tt>
            et. al. remain library classes.
        </p>
        <p>
            If you run
            <pre>
                java soot.Main -i java. --app HelloWorld
            </pre>
            <tt>HelloWorld</tt>
            is still the only argument class, but the set
            of application classes includes the referenced Java runtime
            classes in packages whose names start with <tt>java.</tt> as well
            as <tt>HelloWorld</tt>, <tt>UI</tt>, and <tt>textUI</tt>. The set
            of library classes includes the referenced classes from other
            packages in the Java runtime.
        </p>
    </intro>
    <phaseintro>
        <P>
            Soot supports the powerful--but initially confusing--notion of
            ``phase options''. This document aims to clear up the confusion so
            you can exploit the power of phase options.
        </P>

        <P>
            Soot's execution is divided into a number of phases. For example,
            <TT>JimpleBody</TT>s are built by a phase called <TT>jb</TT>, which is
            itself comprised of subphases, such as the aggregation of local
            variables (<TT>jb.a</TT>).
        </P>

        <P>
            Phase options provide a way for you to
            change the behaviour of a phase from the Soot command-line. They take
            the form
            <TT>-p</TT>
            <EM>phase</EM>.
            <EM>name</EM>
            <EM>option</EM>:<EM>value</EM>. For instance,
            to instruct Soot to use original names in Jimple, we would invoke Soot
            like this:
            <PRE>
                java soot.Main foo -p jb use-original-names:true
            </PRE>
            Multiple option-value pairs may be specified in a single <TT>-p</TT> option
            separated by commas. For example,
            <PRE>
                java soot.Main foo -p cg.spark verbose:true,on-fly-cg:true
            </PRE>
        </P>

        <P>
            There are five types of phase options:
        </P>

        <OL>
            <LI>Boolean options take the values
                ``true'' and ``false''; if you specify the name of a boolean option without adding a value for it,
                ``true'' is assumed.
            </LI>
            <LI>Multi-valued options take a value from a set of allowed values
                specific to that option.
            </LI>
            <LI>Integer options
                take an integer value.
            </LI>
            <LI>Floating point options take a
                floating point number as their value.
            </LI>
            <LI>String options take an arbitrary
                string as their value.
            </LI>
        </OL>

        <P>
            Each option has a default value which is used if the option is not
            specified on the command line.
        </P>

        <P>
            All phases and subphases accept the option ``<TT>enabled</TT>'', which
            must be ``<TT>true</TT>'' for the phase or subphase to execute. To save
            you some typing, the pseudo-options ``<TT>on</TT>'' and ``<TT>off</TT>''
            are equivalent to ``<TT>enabled:true</TT>'' and ``<TT>enabled:false</TT>'',
            respectively. In addition, specifying any options for a phase
            automatically enables that phase.
        </P>

        <H4>Adding your own subphases</H4>

        <P>
            Within Soot, each phase is implemented by a <TT>Pack</TT>. The
            <TT>Pack</TT>
            is a collection of transformers, each corresponding to a subphase of
            the phase implemented by the <TT>Pack</TT>. When the <TT>Pack</TT> is
            called, it executes each of its transformers in order.
        </P>

        <P>
            Soot transformers are usually instances of classes that extend
            <TT>BodyTransformer</TT>
            or <TT>SceneTransformer</TT>. In either case, the
            transformer class must override the <TT>internalTransform</TT> method,
            providing an implementation which carries out some transformation on
            the code being analyzed.
        </P>

        <P>
            To add a transformer to some <TT>Pack</TT> without modifying Soot itself,
            create your own class which changes the contents of the <TT>Pack</TT>s to
            meet your requirements and then calls <TT>soot.Main</TT>.
        </P>

        <P>
            The remainder of this document describes the transformations belonging
            to Soot's various <TT>Pack</TT>s and their corresponding phase
            options.
        </P>
    </phaseintro>
    <section>
        <name>General Options</name>
        <boolopt>
            <name>Coffi Frontend</name>
            <alias>coffi</alias>
            <short_desc>Use the good old Coffi front end for parsing Java bytecode (instead of using ASM).</short_desc>
        </boolopt>
        <boolopt>
            <name>ASM Backend</name>
            <alias>asm-backend</alias>
            <short_desc>Use the ASM back end for generating Java bytecode (instead of using Jasmin).</short_desc>
<<<<<<< HEAD
		</boolopt>
		<boolopt>
			<name>Help</name>
			<alias>h</alias>
			<alias>help</alias>
			<short_desc>Display help and exit</short_desc>
			<long_desc>
Display the textual help message and exit immediately without
further processing.
</long_desc>
		</boolopt>
                <boolopt>
                        <name>Phase List</name>
                        <alias>pl</alias>
                        <alias>phase-list</alias>
                        <short_desc>Print list of available phases</short_desc>
                        <long_desc>
Print a list of the available phases and sub-phases, then exit.
</long_desc>
                </boolopt>
                <listopt>
                        <name>Phase Help</name>
                        <alias>ph</alias>
                        <alias>phase-help</alias>
			<set_arg_label>phase</set_arg_label>
                        <short_desc>Print help for specified <use_arg_label/></short_desc>
                        <long_desc>
Print a help message about the phase or sub-phase named
<use_arg_label/>, then exit.  To see the help message of
more than one phase, specify multiple phase-help options.
</long_desc>
                </listopt>
		<boolopt>
			<name>Version</name>
			<alias>version</alias>
			<short_desc>Display version information and exit</short_desc>
			<long_desc>
Display information about the version of Soot being run, then
exit without further processing.
</long_desc>
		</boolopt>
		<boolopt>
			<name>Verbose</name>
			<alias>v</alias>
			<alias>verbose</alias>
			<short_desc>Verbose mode</short_desc>
			<long_desc>
Provide detailed information about what Soot is doing as it runs.
</long_desc>
		</boolopt>
		<boolopt>
			<name>Interactive Mode</name>
			<alias>interactive-mode</alias>
			<short_desc>Run in interactive mode</short_desc>
			<long_desc>
Runs interactively, with Soot providing detailed information as it iterates through intra-procedural analyses.
</long_desc>
		</boolopt>
		<boolopt>
			<name>Unfriendly Mode</name>
			<alias>unfriendly-mode</alias>
			<short_desc>Allow Soot to run with no command-line options</short_desc>
			<long_desc>
With this option, Soot does not stop even if it received no command-line options. Useful when setting Soot options programmatically and then calling soot.Main.main() with an empty list.
</long_desc>
		</boolopt>
		<boolopt>
			<name>Application Mode</name>
			<alias>app</alias>
			<short_desc>Run in application mode</short_desc>
			<long_desc>
<p>
Run in application mode, processing all classes referenced by
argument classes.</p>
</long_desc>
		</boolopt>
                <boolopt>
			<name>Whole-Program Mode</name>
			<alias>w</alias>
			<alias>whole-program</alias>
                    <short_desc>Run in whole-program mode</short_desc>
			<long_desc>
<p>
Run in whole program mode, taking into consideration the whole
program when performing analyses and transformations. Soot
uses the Call Graph Constructor to build a call graph for the
program, then applies enabled transformations in the Whole-Jimple
Transformation, Whole-Jimple Optimization, and Whole-Jimple
Annotation packs before applying enabled intraprocedural
transformations.</p>
<p>
Note that the Whole-Jimple Optimization pack is normally disabled
(and thus not applied by whole program mode), unless you also
specify the Whole Program Optimize option.</p>
</long_desc>
                </boolopt>
    <boolopt>
      <name>Whole-Shimple Mode</name>
      <alias>ws</alias>
      <alias>whole-shimple</alias>
        <short_desc>Run in whole-shimple mode</short_desc>
      <long_desc>
<p>
Run in whole shimple mode, taking into consideration the whole program
when performing Shimple analyses and transformations. Soot uses the
Call Graph Constructor to build a call graph for the program, then
applies enabled transformations in the Whole-Shimple Transformation
and Whole-Shimple Optimization before applying enabled intraprocedural
transformations.</p>
<p>
Note that the Whole-Shimple Optimization pack is normally disabled
(and thus not applied by whole shimple mode), unless you also
specify the Whole Program Optimize option.</p>
      </long_desc>
    </boolopt>
                <boolopt>
			<name>On-the-fly Mode</name>
			<alias>fly</alias>
			<alias>on-the-fly</alias>
			<default>false</default>
                    <short_desc>Run in on-the-fly mode</short_desc>
			<long_desc>
<p>
This enables whole-program mode but uses a less agressive class loading.
By default, classes will be loaded without bodies unless otherwise requested.
    The cg pack is disabled in this mode.
</p>
</long_desc>
                </boolopt>
    	<boolopt>
			<name>Validate</name>
			<alias>validate</alias>
			<short_desc>Run internal validation on bodies</short_desc>
			<long_desc>
Causes internal checks to be done on bodies in the various Soot IRs,
to make sure the transformations have not done something strange.
This option may degrade Soot's performance.
</long_desc>
                </boolopt>
                <boolopt>
			<name>Debug</name>
			<alias>debug</alias>
			<short_desc>Print various Soot debugging info</short_desc>
			<long_desc>
Print various debugging information as Soot runs, particularly
from the Baf Body Phase and the Jimple Annotation Pack Phase.
</long_desc>
                </boolopt>
                <boolopt>
			<name>Debug Resolver</name>
			<alias>debug-resolver</alias>
			<short_desc>Print debugging info from SootResolver</short_desc>
			<long_desc>
Print debugging information about class resolving.
</long_desc>
                </boolopt>
                <boolopt>
			<name>Ignore Resolving Levels</name>
			<alias>ignore-resolving-levels</alias>
			<short_desc>Ignore mismatching resolving levels</short_desc>
			<long_desc>
If this option is set, Soot will not check whether the current class' resolving level is sufficiently
high for the operation attempted on the class. This allows you to perform any operation on a class
even if the class has not been fully loaded, which can lead to inconsistencies between your Soot scene
and the original classes you loaded. Use this option at your own risk.
</long_desc>
                </boolopt>
	</section>
	<section>
		<name>Input Options</name>
		<stropt>
			<name>Soot Classpath</name>
			<alias>cp</alias>
			<alias>soot-class-path</alias>
			<alias>soot-classpath</alias>
			<set_arg_label>path</set_arg_label>
			<short_desc>Use <use_arg_label/> as the classpath for finding classes.</short_desc>
			<long_desc>
<p>
Use <use_arg_label/> as the list of directories in which Soot
should search for classes. <use_arg_label/> should be a series of
directories, separated by the path separator character for your
system.</p>
<p>
If no classpath is set on the command line, but the system
property <tt>soot.class.path</tt> has been set, Soot uses its
value as the classpath.</p>
<p>
If neither the command line nor the system properties specify a
Soot classpath, Soot falls back on a default classpath consisting
of the value of the system property <tt>java.class.path</tt>
followed <var>java.home</var><tt>/lib/rt.jar</tt>, where
<var>java.home</var> stands for the contents of the system property
<tt>java.home</tt> and <tt>/</tt> stands for the system file
separator.</p>
</long_desc>
		</stropt>

		<stropt>
			<name>Soot Modulepath</name>
			<alias>soot-modulepath</alias>
			<set_arg_label>modulepath</set_arg_label>
			<short_desc>Use <use_arg_label/> as the modulepath for finding classes.</short_desc>
			<long_desc>
				<p>
					Use <use_arg_label/> as the list of directories in which Soot
					should search for classes. <use_arg_label/> should be a series of
					directories, separated by the path separator character for your
					system.</p>
				<p>
					If no modulepath is set on the command line, but the system
					property <tt>soot.module.path</tt> has been set, Soot uses its
					value as the modulepath.</p>
				<p>
					If neither the command line nor the system properties specify a
					Soot classpath, Soot falls back on a default modulepath <tt>jrt:</tt>.</p>
			</long_desc>
		</stropt>

		<boolopt>
			<name>Prepend classpath</name>
			<alias>pp</alias>
			<alias>prepend-classpath</alias>
			<short_desc>Prepend the given soot classpath to the default classpath.</short_desc>
			<long_desc>
<p>
Instead of replacing the default soot classpath with the classpath given on the command line,
prepent it with that classpath.
The default classpath holds whatever is set in the CLASSPATH environment variable,
followed by rt.jar (resolved through the JAVA-UNDERSCORE-HOME environment variable).
If whole-program mode is enabled, jce.jar is also appended in the end.
</p>
</long_desc>
		</boolopt>
		<boolopt>
			<name>Ignore classpath error</name>
			<alias>ice</alias>
			<alias>ignore-classpath-errors</alias>
			<short_desc>Ignores invalid entries on the Soot classpath.</short_desc>
			<long_desc>
<p>
Normally, Soot throws an exception when an invalid classpath entry is detected. To instead silently
ignore such errors, enable this option.
</p>
</long_desc>
		</boolopt>
		<boolopt>
		<name>Process all DEX files in APK</name>
		<alias>process-multiple-dex</alias>
		<short_desc>Process all DEX files found in APK.</short_desc>
		<long_desc>
			<p>
				Android APKs can have more than one default classes.dex. By default Soot loads only classes from the default one. This option
				enables loading of all DEX files from an APK.
			</p>
		</long_desc>
	</boolopt>
		<boolopt>
			<name>Search DEX files in Jar and Zip files</name>
			<alias>search-dex-in-archives</alias>
			<short_desc>Also includes Jar and Zip files when searching for DEX files under the provided classpath.</short_desc>
			<long_desc>
				<p>
					By default, Soot searches for DEX files in APKs and folders. This option instructs Soot to also search for DEX files in Zip and Jar files on the classpath.
				</p>
			</long_desc>
		</boolopt>
		<listopt>
			<name>Process Directories</name>
			<alias>process-path</alias>
			<alias>process-dir</alias>
			<set_arg_label>dir</set_arg_label>
			<short_desc>Process all classes found in <use_arg_label/></short_desc>
			<long_desc>
<p>
Add all classes found in <use_arg_label/> to the set of argument classes
which is analyzed and transformed by Soot.  You can specify the
option more than once, to add argument classes from multiple directories.
You can also state JAR files.
</p>
<p>
If subdirectories of <use_arg_label/> contain <tt>.class</tt> or
<tt>.jimple</tt> files, Soot assumes that the subdirectory names
correspond to components of the classes' package names. If
<use_arg_label/> contains <tt>subA/subB/MyClass.class</tt>, for
instance, then Soot assumes <tt>MyClass</tt> is in package
<tt>subA.subB</tt>.</p>
</long_desc>
		</listopt>
		<boolopt>
			<name>One at a time</name>
			<alias>oaat</alias>
			<short_desc>From the process-dir, processes one class at a time.</short_desc>
			<long_desc>
This option is meant to keep memory consumption low. If enabled, the
-process-dir option must be used as well. From the process-dir, Soot
will process one class at a time. Only body packs are run,
=======
        </boolopt>
        <boolopt>
            <name>Help</name>
            <alias>h</alias>
            <alias>help</alias>
            <short_desc>Display help and exit</short_desc>
            <long_desc>
                Display the textual help message and exit immediately without
                further processing.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Phase List</name>
            <alias>pl</alias>
            <alias>phase-list</alias>
            <short_desc>Print list of available phases</short_desc>
            <long_desc>
                Print a list of the available phases and sub-phases, then exit.
            </long_desc>
        </boolopt>
        <listopt>
            <name>Phase Help</name>
            <alias>ph</alias>
            <alias>phase-help</alias>
            <set_arg_label>phase</set_arg_label>
            <short_desc>Print help for specified
                <use_arg_label/>
            </short_desc>
            <long_desc>
                Print a help message about the phase or sub-phase named
                <use_arg_label/>, then exit. To see the help message of
                more than one phase, specify multiple phase-help options.
            </long_desc>
        </listopt>
        <boolopt>
            <name>Version</name>
            <alias>version</alias>
            <short_desc>Display version information and exit</short_desc>
            <long_desc>
                Display information about the version of Soot being run, then
                exit without further processing.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Verbose</name>
            <alias>v</alias>
            <alias>verbose</alias>
            <short_desc>Verbose mode</short_desc>
            <long_desc>
                Provide detailed information about what Soot is doing as it runs.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Interactive Mode</name>
            <alias>interactive-mode</alias>
            <short_desc>Run in interactive mode</short_desc>
            <long_desc>
                Runs interactively, with Soot providing detailed information as it iterates through intra-procedural
                analyses.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Unfriendly Mode</name>
            <alias>unfriendly-mode</alias>
            <short_desc>Allow Soot to run with no command-line options</short_desc>
            <long_desc>
                With this option, Soot does not stop even if it received no command-line options. Useful when setting
                Soot options programmatically and then calling soot.Main.main() with an empty list.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Application Mode</name>
            <alias>app</alias>
            <short_desc>Run in application mode</short_desc>
            <long_desc>
                <p>
                    Run in application mode, processing all classes referenced by
                    argument classes.
                </p>
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Whole-Program Mode</name>
            <alias>w</alias>
            <alias>whole-program</alias>
            <short_desc>Run in whole-program mode</short_desc>
            <long_desc>
                <p>
                    Run in whole program mode, taking into consideration the whole
                    program when performing analyses and transformations. Soot
                    uses the Call Graph Constructor to build a call graph for the
                    program, then applies enabled transformations in the Whole-Jimple
                    Transformation, Whole-Jimple Optimization, and Whole-Jimple
                    Annotation packs before applying enabled intraprocedural
                    transformations.
                </p>
                <p>
                    Note that the Whole-Jimple Optimization pack is normally disabled
                    (and thus not applied by whole program mode), unless you also
                    specify the Whole Program Optimize option.
                </p>
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Whole-Shimple Mode</name>
            <alias>ws</alias>
            <alias>whole-shimple</alias>
            <short_desc>Run in whole-shimple mode</short_desc>
            <long_desc>
                <p>
                    Run in whole shimple mode, taking into consideration the whole program
                    when performing Shimple analyses and transformations. Soot uses the
                    Call Graph Constructor to build a call graph for the program, then
                    applies enabled transformations in the Whole-Shimple Transformation
                    and Whole-Shimple Optimization before applying enabled intraprocedural
                    transformations.
                </p>
                <p>
                    Note that the Whole-Shimple Optimization pack is normally disabled
                    (and thus not applied by whole shimple mode), unless you also
                    specify the Whole Program Optimize option.
                </p>
            </long_desc>
        </boolopt>
        <boolopt>
            <name>On-the-fly Mode</name>
            <alias>fly</alias>
            <alias>on-the-fly</alias>
            <default>false</default>
            <short_desc>Run in on-the-fly mode</short_desc>
            <long_desc>
                <p>
                    This enables whole-program mode but uses a less agressive class loading.
                    By default, classes will be loaded without bodies unless otherwise requested.
                    The cg pack is disabled in this mode.
                </p>
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Validate</name>
            <alias>validate</alias>
            <short_desc>Run internal validation on bodies</short_desc>
            <long_desc>
                Causes internal checks to be done on bodies in the various Soot IRs,
                to make sure the transformations have not done something strange.
                This option may degrade Soot's performance.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Debug</name>
            <alias>debug</alias>
            <short_desc>Print various Soot debugging info</short_desc>
            <long_desc>
                Print various debugging information as Soot runs, particularly
                from the Baf Body Phase and the Jimple Annotation Pack Phase.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Debug Resolver</name>
            <alias>debug-resolver</alias>
            <short_desc>Print debugging info from SootResolver</short_desc>
            <long_desc>
                Print debugging information about class resolving.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Ignore Resolving Levels</name>
            <alias>ignore-resolving-levels</alias>
            <short_desc>Ignore mismatching resolving levels</short_desc>
            <long_desc>
                If this option is set, Soot will not check whether the current class' resolving level is sufficiently
                high for the operation attempted on the class. This allows you to perform any operation on a class
                even if the class has not been fully loaded, which can lead to inconsistencies between your Soot scene
                and the original classes you loaded. Use this option at your own risk.
            </long_desc>
        </boolopt>
    </section>
    <section>
        <name>Input Options</name>
        <stropt>
            <name>Soot Classpath</name>
            <alias>cp</alias>
            <alias>soot-class-path</alias>
            <alias>soot-classpath</alias>
            <set_arg_label>path</set_arg_label>
            <short_desc>Use
                <use_arg_label/>
                as the classpath for finding classes.
            </short_desc>
            <long_desc>
                <p>
                    Use
                    <use_arg_label/>
                    as the list of directories in which Soot
                    should search for classes.
                    <use_arg_label/>
                    should be a series of
                    directories, separated by the path separator character for your
                    system.
                </p>
                <p>
                    If no classpath is set on the command line, but the system
                    property <tt>soot.class.path</tt> has been set, Soot uses its
                    value as the classpath.
                </p>
                <p>
                    If neither the command line nor the system properties specify a
                    Soot classpath, Soot falls back on a default classpath consisting
                    of the value of the system property
                    <tt>java.class.path</tt>
                    followed
                    <var>java.home</var>
                    <tt>/lib/rt.jar</tt>, where
                    <var>java.home</var>
                    stands for the contents of the system property
                    <tt>java.home</tt>
                    and <tt>/</tt> stands for the system file
                    separator.
                </p>
            </long_desc>
        </stropt>
        <boolopt>
            <name>Prepend classpath</name>
            <alias>pp</alias>
            <alias>prepend-classpath</alias>
            <short_desc>Prepend the given soot classpath to the default classpath.</short_desc>
            <long_desc>
                <p>
                    Instead of replacing the default soot classpath with the classpath given on the command line,
                    prepent it with that classpath.
                    The default classpath holds whatever is set in the CLASSPATH environment variable,
                    followed by rt.jar (resolved through the JAVA-UNDERSCORE-HOME environment variable).
                    If whole-program mode is enabled, jce.jar is also appended in the end.
                </p>
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Ignore classpath error</name>
            <alias>ice</alias>
            <alias>ignore-classpath-errors</alias>
            <short_desc>Ignores invalid entries on the Soot classpath.</short_desc>
            <long_desc>
                <p>
                    Normally, Soot throws an exception when an invalid classpath entry is detected. To instead silently
                    ignore such errors, enable this option.
                </p>
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Process all DEX files in APK</name>
            <alias>process-multiple-dex</alias>
            <short_desc>Process all DEX files found in APK.</short_desc>
            <long_desc>
                <p>
                    Android APKs can have more than one default classes.dex. By default Soot loads only classes from the
                    default one. This option
                    enables loading of all DEX files from an APK.
                </p>
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Search DEX files in Jar and Zip files</name>
            <alias>search-dex-in-archives</alias>
            <short_desc>Also includes Jar and Zip files when searching for DEX files under the provided classpath.
            </short_desc>
            <long_desc>
                <p>
                    By default, Soot searches for DEX files in APKs and folders. This option instructs Soot to also
                    search for DEX files in Zip and Jar files on the classpath.
                </p>
            </long_desc>
        </boolopt>
        <listopt>
            <name>Process Directories</name>
            <alias>process-path</alias>
            <alias>process-dir</alias>
            <set_arg_label>dir</set_arg_label>
            <short_desc>Process all classes found in
                <use_arg_label/>
            </short_desc>
            <long_desc>
                <p>
                    Add all classes found in
                    <use_arg_label/>
                    to the set of argument classes
                    which is analyzed and transformed by Soot. You can specify the
                    option more than once, to add argument classes from multiple directories.
                    You can also state JAR files.
                </p>
                <p>
                    If subdirectories of
                    <use_arg_label/>
                    contain <tt>.class</tt> or
                    <tt>.jimple</tt>
                    files, Soot assumes that the subdirectory names
                    correspond to components of the classes' package names. If
                    <use_arg_label/>
                    contains <tt>subA/subB/MyClass.class</tt>, for
                    instance, then Soot assumes <tt>MyClass</tt> is in package
                    <tt>subA.subB</tt>.
                </p>
            </long_desc>
        </listopt>
        <boolopt>
            <name>One at a time</name>
            <alias>oaat</alias>
            <short_desc>From the process-dir, processes one class at a time.</short_desc>
            <long_desc>
                This option is meant to keep memory consumption low. If enabled, the
                -process-dir option must be used as well. From the process-dir, Soot
                will process one class at a time. Only body packs are run,
>>>>>>> origin/develop
                no whole-program packs.
            </long_desc>
        </boolopt>
        <stropt>
            <name>Path to Android jar files</name>
            <alias>android-jars</alias>
            <set_arg_label>path</set_arg_label>
            <short_desc>Use
                <use_arg_label/>
                as the path for finding the android.jar file
            </short_desc>
            <long_desc>
                Use
                <use_arg_label/>
                as the directory in which Soot should search for the appropriate
                android.jar file to use.
                The directory must contain subdirectories named after the Android SDK version. Those
                subdirectories must each contain one android.jar file.
                For instance if the target directory is /home/user/androidSDK/platforms/ subdirectories
                containing android.jar for Android SDK 8 and 13 must be named android-8/ and android-13/
                respectively.

                Note, that this options requires that only one Android application is analyzed at a time.
                The Android application must contain the AndroidManifest.xml file.
            </long_desc>
        </stropt>
        <stropt>
            <name>Force specific Android jar file</name>
            <alias>force-android-jar</alias>
            <set_arg_label>path</set_arg_label>
            <short_desc>Force Soot to use
                <use_arg_label/>
                as the path for the android.jar file.
            </short_desc>
            <long_desc>
                Use
                <use_arg_label/>
                as the path to the android.jar file Soot should use.
                This option overrides the 'android-jars' option. If the 'android-api-version' option is not specified,
                Soot will try to parse the API version from the given file path. If that fails, it will fall back to the
                default. If the 'android-api-version' option is specified, the API version used for parsing will be
                taken
                from there.
            </long_desc>
        </stropt>
        <intopt>
            <name>Force specific Android API version</name>
            <alias>android-api-version</alias>
            <set_arg_label>version</set_arg_label>
            <short_desc>Force Soot to use
                <use_arg_label/>
                as the API version when readin in APK or DEX files.
            </short_desc>
            <long_desc>
                Use
                <use_arg_label/>
                as the Android API version that Soot should use when processing APK or DEX files.
                When combined with the 'android-jars' option, this value will take precedence over the API version
                specified in the
                app's manifest file. When combined with the 'force-android-jar' option, the JAR file will be the one
                from the
                'force-android-jar' option, but the API version used for parsing will be the explicitly given one.
            </long_desc>
        </intopt>

        <boolopt>
            <name>Compute AST Metrics</name>
            <alias>ast-metrics</alias>
            <short_desc>Compute AST Metrics if performing java to jimple</short_desc>
            <long_desc>
                If this flag is set and soot converts java to jimple then AST metrics will be computed.
            </long_desc>
        </boolopt>
        <multiopt>
            <name>Input Source Precedence</name>
            <alias>src-prec</alias>
            <set_arg_label>format</set_arg_label>
            <short_desc>Sets source precedence to
                <use_arg_label/>
                files
            </short_desc>
            <long_desc>
                Sets
                <use_arg_label/>
                as Soot's preference for the type of source files to read when
                it looks for a class.
            </long_desc>
            <value>
                <name>Class File</name>
                <alias>c</alias>
                <alias>class</alias>
                <short_desc>Favour class files as Soot source</short_desc>
                <long_desc>
                    Try to resolve classes first from <tt>.class</tt> files found in
                    the Soot classpath. Fall back to <tt>.jimple</tt> files
                    only when unable to find a <tt>.class</tt> file.
                </long_desc>
                <default/>
            </value>
            <value>
                <name>Only Class File</name>
                <alias>only-class</alias>
                <short_desc>Use only class files as Soot source</short_desc>
                <long_desc>
                    Try to resolve classes first from <tt>.class</tt> files found in
                    the Soot classpath. Do not try any other types of files even when
                    unable to find a <tt>.class</tt> file.
                </long_desc>
            </value>
            <value>
                <name>Jimple File</name>
                <alias>J</alias>
                <alias>jimple</alias>
                <short_desc>Favour Jimple files as Soot source</short_desc>
                <long_desc>
                    Try to resolve classes first from <tt>.jimple</tt> files found in
                    the Soot classpath. Fall back to <tt>.class</tt> files only when
                    unable to find a <tt>.jimple</tt> file.
                </long_desc>
            </value>
            <value>
                <name>Java File</name>
                <alias>java</alias>
                <short_desc>Favour Java files as Soot source</short_desc>
                <long_desc>
                    Try to resolve classes first from <tt>.java</tt> files found in
                    the Soot classpath. Fall back to <tt>.class</tt> files only when
                    unable to find a <tt>.java</tt> file.
                </long_desc>
            </value>
            <value>
                <name>APK File</name>
                <alias>apk</alias>
                <short_desc>Favour APK files as Soot source</short_desc>
                <long_desc>
                    Try to resolve classes first from <tt>.apk</tt> (Android Package) files found in
                    the Soot classpath. Fall back to <tt>.class</tt>, <tt>.java</tt> or
                    <tt>.jimple</tt>
                    files only when unable to find a class in <tt>.apk</tt> files.
                </long_desc>
            </value>
            <value>
                <name>APK File</name>
                <alias>apk-class-jimple</alias>
                <alias>apk-c-j</alias>
                <short_desc>Favour APK files as Soot source, disregard Java files</short_desc>
                <long_desc>
                    Try to resolve classes first from <tt>.apk</tt> (Android Package) files found in
                    the Soot classpath. Fall back to <tt>.class</tt>, or
                    <tt>.jimple</tt>
                    files only when unable to find a class in <tt>.apk</tt> files. Never load a
                    <tt>.java</tt>
                    file.
                </long_desc>
            </value>
        </multiopt>
        <boolopt>
            <name>Force complete resolver</name>
            <alias>full-resolver</alias>
            <short_desc>Force transitive resolving of referenced classes</short_desc>
            <long_desc>
                Normally, Soot resolves only that application classes and any classes that they
                refer to, along with any classes it needs for the Jimple typing, but it does not
                transitively resolve references in these additional classes that were resolved
                only because they were referenced. This switch forces full transitive resolution
                of all references found in all classes that are resolved, regardless of why they
                were resolved.

                In whole-program mode, class resolution is always fully transitive. Therefore,
                in whole-program mode, this switch has no effect, and class resolution is
                always performed as if it were turned on.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Allow Phantom References</name>
            <alias>allow-phantom-refs</alias>
            <short_desc>Allow unresolved classes; may cause errors</short_desc>
            <long_desc>
                Allow Soot to process a class even if it cannot find all classes
                referenced by that class. This may cause Soot to produce
                incorrect results.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Allow Phantom References</name>
            <alias>no-bodies-for-excluded</alias>
            <short_desc>Do not load bodies for excluded classes</short_desc>
            <long_desc>
                Prevents Soot from loading method bodies for all excluded classes (see exclude option), even
                when running in whole-program mode. This is useful for computing a shallow points-to analysis
                that does not, for instance, take into account the JDK. Of course, such analyses may be unsound.
                You get what you are asking for.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Use J2ME mode</name>
            <alias>j2me</alias>
            <default>false</default>
            <short_desc>Use J2ME mode; changes assignment of types</short_desc>
            <long_desc>
                Use J2ME mode. J2ME does not have class Cloneable nor Serializable, so we have
                to change type assignment to not refer to those classes.
            </long_desc>
        </boolopt>
        <stropt>
            <name>Main Class</name>
            <alias>main-class</alias>
            <set_arg_label>class</set_arg_label>
            <short_desc>Sets the main class for whole-program analysis.</short_desc>
            <long_desc>
                <p>
                    By default, the first class encountered with a main method is treated
                    as the main class (entry point) in whole-program analysis. This option
                    overrides this default.
                </p>
            </long_desc>
        </stropt>
        <boolopt>
            <name>Use Polyglot frontend</name>
            <alias>polyglot</alias>
            <default>false</default>
            <short_desc>Use Java 1.4 Polyglot frontend instead of JastAdd</short_desc>
            <long_desc>
                Use Java 1.4 Polyglot frontend instead of JastAdd, which supports Java 5 syntax.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Use permissive resolving strategy</name>
            <alias>permissive-resolving</alias>
            <default>false</default>
            <short_desc>Use alternative sources when classes cannot be found using the normal resolving strategy
            </short_desc>
            <long_desc>
                When this option is enabled, Soot will try to resolve classes using an alternative
                strategy if the class cannot be found using the default strategy. A class a.b.c
                will, for instance, also be loaded from a/b/c.jimple instead of only a.b.c.jimple.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Drop method source after loading bodies</name>
            <alias>drop-bodies-after-load</alias>
            <default>true</default>
            <short_desc>Drop the method source after it has served its purpose of loading the method body</short_desc>
            <long_desc>
                Each method is associated with a method source for loading its body. When this option is disabled,
                a reference to this source is kept around even after the body has already been loaded. This is a waste
                of memory for most use cases. When this option is enabled, the reference is dropped, allowing for
                garbage
                collection of the method source. On the other hand, if the body is ever released, it cannot easily be
                recovered (i.e., loaded again) easily.
            </long_desc>
        </boolopt>
    </section>
    <section>
        <name>Output Options</name>
        <stropt>
            <name>Output Directory</name>
            <alias>d</alias>
            <alias>output-dir</alias>
            <default>./sootOutput</default>
            <set_arg_label>dir</set_arg_label>
            <short_desc>Store output files in
                <use_arg_label/>
            </short_desc>
            <long_desc>
                Store output files in<use_arg_label/>.
                <use_arg_label/>
                may be
                relative to the working directory.
            </long_desc>
        </stropt>
        <multiopt>
            <name>Output Format</name>
            <alias>f</alias>
            <alias>output-format</alias>
            <set_arg_label>format</set_arg_label>
            <short_desc>Set output format for Soot</short_desc>
            <long_desc>
                <p>
                    Specify the format of output files Soot should produce, if
                    any.
                </p>
                <p>
                    Note that while the abbreviated formats (<tt>jimp</tt>,
                    <tt>shimp</tt>, <tt>b</tt>, and <tt>grimp</tt>) are easier to
                    read than their unabbreviated counterparts (<tt>jimple</tt>,
                    <tt>shimple</tt>, <tt>baf</tt>, and <tt>grimple</tt>), they may
                    contain ambiguities. Method signatures in the abbreviated
                    formats, for instance, are not uniquely determined.
                </p>
            </long_desc>
            <value>
                <name>Jimple File</name>
                <alias>J</alias>
                <alias>jimple</alias>
                <short_desc>Produce <tt>.jimple</tt> Files
                </short_desc>
                <long_desc>
                    Produce <tt>.jimple</tt> files, which contain a textual
                    form of Soot's Jimple internal representation.
                </long_desc>
            </value>
            <value>
                <name>Jimp File</name>
                <alias>j</alias>
                <alias>jimp</alias>
                <short_desc>Produce <tt>.jimp</tt> (abbreviated Jimple) files
                </short_desc>
                <long_desc>
                    Produce <tt>.jimp</tt> files, which contain an abbreviated form
                    of Jimple.
                </long_desc>
            </value>
            <value>
                <name>Shimple File</name>
                <alias>S</alias>
                <alias>shimple</alias>
                <short_desc>Produce <tt>.shimple</tt> files
                </short_desc>
                <long_desc>
                    Produce <tt>.shimple files</tt>, containing a textual form of
                    Soot's SSA Shimple internal representation. Shimple adds
                    Phi nodes to Jimple.
                </long_desc>
            </value>
            <value>
                <name>Shimp File</name>
                <alias>s</alias>
                <alias>shimp</alias>
                <short_desc>Produce <tt>.shimp</tt> (abbreviated Shimple) files
                </short_desc>
                <long_desc>
                    Produce .shimp files, which contain an abbreviated form of
                    Shimple.
                </long_desc>
            </value>
            <value>
                <name>Baf File</name>
                <alias>B</alias>
                <alias>baf</alias>
                <short_desc>Produce <tt>.baf</tt> files
                </short_desc>
                <long_desc>
                    Produce <tt>.baf</tt> files, which contain a textual form of
                    Soot's Baf internal representation.
                </long_desc>
            </value>
            <value>
                <name>Abbreviated Baf File</name>
                <alias>b</alias>
                <short_desc>Produce <tt>.b</tt> (abbreviated Baf) files
                </short_desc>
                <long_desc>
                    Produce <tt>.b</tt> files, which contain an abbreviated form of Baf.
                </long_desc>
            </value>
            <value>
                <name>Grimp File</name>
                <alias>G</alias>
                <alias>grimple</alias>
                <short_desc>Produce <tt>.grimple</tt> files
                </short_desc>
                <long_desc>
                    Produce <tt>.grimple</tt> files, which contain a textual
                    form of Soot's Grimp internal representation.
                </long_desc>
            </value>
            <value>
                <name>Abbreviated Grimp File</name>
                <alias>g</alias>
                <alias>grimp</alias>
                <short_desc>Produce <tt>.grimp</tt> (abbreviated Grimp) files
                </short_desc>
                <long_desc>
                    Produce <tt>.grimp</tt> files, which contain an abbreviated form
                    of Grimp.
                </long_desc>
            </value>
            <value>
                <name>Xml File</name>
                <alias>X</alias>
                <alias>xml</alias>
                <short_desc>Produce <tt>.xml</tt> Files
                </short_desc>
                <long_desc>
                    Produce <tt>.xml</tt> files containing an annotated
                    version of the Soot's Jimple internal representation.
                </long_desc>
            </value>
            <value>
                <name>Dalvik Executable File</name>
                <alias>dex</alias>
                <short_desc>Produce Dalvik Virtual Machine files</short_desc>
                <long_desc>Produce Dalvik Virtual Machine files. If input was an Android
                    Package (APK), a new APK is generated with it's classes.dex replaced. If
                    no input APK is found, only a classes.dex is generated.
                </long_desc>
            </value>
            <value>
                <name>Dalvik Executable File</name>
                <alias>force-dex</alias>
                <short_desc>Produce Dalvik DEX files</short_desc>
                <long_desc>Produce Dalvik Virtual Machine files. This option always creates
                    a stand-alone DEX file, even if the input was read from an Android Package (APK).
                </long_desc>
            </value>
            <value>
                <name>No Output File</name>
                <alias>n</alias>
                <alias>none</alias>
                <short_desc>Produce no output</short_desc>
                <long_desc>
                    Produce no output files.
                </long_desc>
            </value>
            <value>
                <name>Jasmin File</name>
                <alias>jasmin</alias>
                <short_desc>Produce <tt>.jasmin</tt> files
                </short_desc>
                <long_desc>
                    Produce <tt>.jasmin</tt> files, suitable as input to the jasmin
                    bytecode assembler.
                </long_desc>
            </value>
            <value>
                <name>Class File</name>
                <alias>c</alias>
                <alias>class</alias>
                <default/>
                <short_desc>Produce <tt>.class</tt> Files
                </short_desc>
                <long_desc>
                    Produce Java <tt>.class</tt> files, executable by any Java
                    Virtual Machine.
                </long_desc>
            </value>
            <value>
                <name>Dava Decompiled File</name>
                <alias>d</alias>
                <alias>dava</alias>
                <short_desc>Produce dava-decompiled <tt>.java</tt> files
                </short_desc>
                <long_desc>
                    Produce <tt>.java</tt> files generated by the Dava decompiler.
                </long_desc>
            </value>
            <value>
                <name>Jimle Template File</name>
                <alias>t</alias>
                <alias>template</alias>
                <short_desc>Produce <tt>.java</tt> files with Jimple templates.
                </short_desc>
                <long_desc>
                    Produce <tt>.java</tt> files with Jimple templates.
                </long_desc>
            </value>
            <value>
                <name>ASM File</name>
                <alias>a</alias>
                <alias>asm</alias>
                <short_desc>Produce <tt>.asm</tt> files as textual bytecode representation generated with the ASM back
                    end.
                </short_desc>
                <long_desc>
                    Produce <tt>.asm</tt> files as textual bytecode representation generated with the ASM back end.
                </long_desc>
            </value>
        </multiopt>
        <multiopt>
            <name>Java version</name>
            <alias>java-version</alias>
            <default>default</default>
            <set_arg_label>version</set_arg_label>
            <short_desc>Force Java version of bytecode generated by Soot.</short_desc>
            <long_desc>
                <p>
                    Force Java version of bytecode generated by Soot.
                </p>
                <p>
                    This option can only be set on
                    <tt>output-format class</tt>
                    and <tt>asm-backend</tt> set, or on
                    <tt>output-format asm</tt>
                </p>
            </long_desc>
            <value>
                <name>Default behavior</name>
                <alias>default</alias>
                <short_desc>Let Soot determine Java version of generated bytecode.</short_desc>
                <long_desc>
                    Let Soot determine Java version of generated bytecode.
                </long_desc>
            </value>
            <value>
                <name>Java 1.1</name>
                <alias>1.1</alias>
                <alias>1</alias>
                <short_desc>Force Java 1.1 as output version.</short_desc>
                <long_desc>
                    Force Java 1.1 as output version.
                </long_desc>
            </value>
            <value>
                <name>Java 1.2</name>
                <alias>1.2</alias>
                <alias>2</alias>
                <short_desc>Force Java 1.2 as output version.</short_desc>
                <long_desc>
                    Force Java 1.2 as output version.
                </long_desc>
            </value>
            <value>
                <name>Java 1.3</name>
                <alias>1.3</alias>
                <alias>3</alias>
                <short_desc>Force Java 1.3 as output version.</short_desc>
                <long_desc>
                    Force Java 1.3 as output version.
                </long_desc>
            </value>
            <value>
                <name>Java 1.4</name>
                <alias>1.4</alias>
                <alias>4</alias>
                <short_desc>Force Java 1.4 as output version.</short_desc>
                <long_desc>
                    Force Java 1.4 as output version.
                </long_desc>
            </value>
            <value>
                <name>Java 1.5</name>
                <alias>1.5</alias>
                <alias>5</alias>
                <short_desc>Force Java 1.5 as output version.</short_desc>
                <long_desc>
                    Force Java 1.5 as output version.
                </long_desc>
            </value>
            <value>
                <name>Java 1.6</name>
                <alias>1.6</alias>
                <alias>6</alias>
                <short_desc>Force Java 1.6 as output version.</short_desc>
                <long_desc>
                    Force Java 1.6 as output version.
                </long_desc>
            </value>
            <value>
                <name>Java 1.7</name>
                <alias>1.7</alias>
                <alias>7</alias>
                <short_desc>Force Java 1.7 as output version.</short_desc>
                <long_desc>
                    Force Java 1.7 as output version.
                </long_desc>
            </value>
            <value>
                <name>Java 1.8</name>
                <alias>1.8</alias>
                <alias>8</alias>
                <short_desc>Force Java 1.8 as output version.</short_desc>
                <long_desc>
                    Force Java 1.8 as output version.
                </long_desc>
            </value>
        </multiopt>
        <boolopt>
            <name>Output Jar File</name>
            <alias>outjar</alias>
            <alias>output-jar</alias>
            <short_desc>Make output dir a Jar file instead of dir</short_desc>
            <long_desc>
                Saves output files into a Jar file instead of a directory. The output
                Jar file name should be specified using the Output Directory
                (<tt>output-dir</tt>) option. Note that if the output Jar file exists
                before Soot runs, any files inside it will first be removed.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Save Tags to XML</name>
            <alias>xml-attributes</alias>
            <short_desc>Save tags to XML attributes for Eclipse</short_desc>
            <long_desc>
                Save in XML format a variety of tags which Soot has attached to
                its internal representations of the application classes. The XML
                file can then be read by the Soot plug-in for the Eclipse IDE,
                which can display the annotations together with the program
                source, to aid program understanding.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Print Tags in Output</name>
            <alias>print-tags</alias>
            <alias>print-tags-in-output</alias>
            <short_desc>Print tags in output files after stmt</short_desc>
            <long_desc>
                Print in output files (either in Jimple or Dave) a variety of tags which
                Soot has attached to
                its internal representations of the application classes. The tags will
                be printed on the line succeeding the stmt that they are attached to.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Don't Output Source File Attribute</name>
            <alias>no-output-source-file-attribute</alias>
            <short_desc>Don't output Source File Attribute when producing class files</short_desc>
            <long_desc>
                Don't output Source File Attribute when producing class files.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Don't Output Inner Classes Attribute</name>
            <alias>no-output-inner-classes-attribute</alias>
            <short_desc>Don't output inner classes attribute in class files</short_desc>
            <long_desc>
                Don't output inner classes attribute in class files.
            </long_desc>
        </boolopt>
        <listopt>
            <name>Body Dumping Phases</name>
            <alias>dump-body</alias>
            <set_arg_label>phaseName</set_arg_label>
            <short_desc>Dump the internal representation of each method before and after phase
                <use_arg_label/>
            </short_desc>
            <long_desc>
                <p>
                    Specify that
                    <use_arg_label/>
                    is one of the phases to be dumped.
                    For example <code>-dump-body jb -dump-body jb.a</code> would dump each
                    method before and after the <code>jb</code> and
                    <code>jb.a</code>
                    phases. The pseudo phase name ``<code>ALL</code>''
                    causes all phases to be dumped.
                </p>
                <p>
                    Output files appear in subdirectories under the
                    soot output directory, with names like
                    <var>className</var>
                    <code>/</code>
                    <var>methodSignature</var>
                    <code>/</code>
                    <var>phasename</var>
                    <code>-</code>
                    <var>graphType</var>
                    <code>-</code>
                    <var>number</var>
                    <code>.in</code>
                    and
                    <var>className</var>
                    <code>/</code>
                    <var>methodSignature</var>
                    <code>/</code>
                    <var>phasename</var>
                    <code>-</code>
                    <var>graphType</var>
                    <code>-</code>
                    <var>number</var>
                    <code>.out</code>.
                    The ``<code>in</code>'' and
                    ``<code>out</code>'' suffixes distinguish the internal
                    representations of the method before and after the phase
                    executed.
                </p>
            </long_desc>
        </listopt>
        <listopt>
            <name>CFG Dumping Phases</name>
            <alias>dump-cfg</alias>
            <set_arg_label>phaseName</set_arg_label>
            <short_desc>Dump the internal representation of each CFG constructed during phase
                <use_arg_label/>
            </short_desc>
            <long_desc>
                <p>
                    Specify that any control flow graphs constructed during the
                    <use_arg_label/>
                    phases should be dumped.
                    For example <code>-dump-cfg jb -dump-cfg bb.lso</code> would dump
                    all
                    CFGs constructed during the <code>jb</code> and
                    <code>bb.lso</code>
                    phases. The pseudo phase name ``<code>ALL</code>''
                    causes CFGs constructed in all phases to be dumped.
                </p>
                <p>The control flow graphs are dumped in the form
                    of a file containing input to <code>dot</code> graph visualization
                    tool. Output <code>dot</code> files are stored beneath the soot
                    output directory, in files with names like:
                    <var>className</var>
                    <code>/</code>
                    <var>methodSignature</var>
                    <code>/</code>
                    <var>phasename</var>
                    <code>-</code>
                    <var>graphType</var>
                    <code>-</code>
                    <var>number</var>
                    <code>.dot</code>,
                    where <var>number</var> serves to distinguish graphs in phases
                    that produce more than one (for example, the Aggregator may
                    produce multiple <code>ExceptionalUnitGraph</code>s).
                </p>
            </long_desc>
        </listopt>
        <boolopt>
            <name>Show Exception Destinations</name>
            <alias>show-exception-dests</alias>
            <default>true</default>
            <short_desc>Include exception destination edges as well as CFG edges in dumped CFGs</short_desc>
            <long_desc>
                Indicate whether to show exception destination edges as
                well as control flow edges in
                dumps of exceptional control flow graphs.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>GZipped IR output</name>
            <alias>gzip</alias>
            <default>false</default>
            <short_desc>GZip IR output files</short_desc>
            <long_desc>
                This option causes Soot to compress output files of intermediate representations
                with GZip. It does not apply to class files output by Soot.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Force Overwrite Output Files</name>
            <alias>force-overwrite</alias>
            <default>false</default>
            <short_desc>Force Overwrite Output Files</short_desc>
            <long_desc>
                If this option is set to true, the output files will be overwritten
                if they already exist and no further warning will be issued.
            </long_desc>
        </boolopt>
    </section>
    <section>
        <name>Processing Options</name>
        <listopt>
            <name>Plugin Configuration</name>
            <alias>plugin</alias>
            <set_arg_label>file</set_arg_label>
            <short_desc>Load all plugins found in
                <use_arg_label/>
            </short_desc>
            <long_desc>
                <p>
                    Loads the plugin configuration
                    <use_arg_label/>
                    and registers
                    all plugins. Make sure that the option is specified before you
                    try to pass options to the loaded plugins.
                </p>
            </long_desc>
        </listopt>

        <multiopt>
            <name>Handling of Wrong Staticness</name>
            <alias>wrong-staticness</alias>
            <short_desc>Ignores or fixes errors due to wrong staticness</short_desc>
            <long_desc>
                Some projects have been shown to contain invalid bytecode that tries to access
                a static field or method in a non-static way or the other way around. The VM's bytecode
                verifier will reject such bytecode when loaded into the VM. This option, depending on
                then chosen value, either causes to create Jimple bodies in such cases nontheless, ignoring
                the error, or automatically fixes the error when possible.
            </long_desc>
            <value>
                <name>Fail</name>
                <alias>fail</alias>
                <short_desc>Raise an error when wrong staticness is detected</short_desc>
                <long_desc>
                    When this value is used, the analysis raises an error when code that accesses a static
                    field using instance field operations is detected.
                </long_desc>
            </value>
            <value>
                <name>Ignore</name>
                <alias>ignore</alias>
                <short_desc>Ignore errors caused by wrong staticness</short_desc>
                <long_desc>
                    When this option is enabled, Soot will accept field accesses when in the case of wrong
                    staticness and will create the Jimple code equivalent to the (broken) input code nevertheless.
                    The Jimple code will then be invalid, but will exactly resemble the input code.
                </long_desc>
            </value>
            <value>
                <name>Fix</name>
                <alias>fix</alias>
                <short_desc>Transparently fix staticness errors</short_desc>
                <default/>
                <long_desc>
                    When Soot detects a case in which a static field is accessed as if it were an instance field, Soot
                    will transparently fix the error and generate Jimple code for the fixed program. If a problem cannot
                    be fixed, an access to that method or field will not throw an exception.
                </long_desc>
            </value>
            <value>
                <name>FixStrict</name>
                <alias>fixstrict</alias>
                <short_desc>Transparently fix staticness errors, but do not ignore remaining errors</short_desc>
                <default/>
                <long_desc>
                    When Soot detects a case in which a static field is accessed as if it were an instance field, Soot
                    will transparently fix the error and generate Jimple code for the fixed program. If a problem cannot
                    be fixed, an access to that method or field will still throw an exception. This makes sure that
                    problems
                    cannot silently disappear and cause invalid Jimple code.
                </long_desc>
            </value>
        </multiopt>

        <multiopt>
            <name>Handling of Field Type Mismatches</name>
            <alias>field-type-mismatches</alias>
            <short_desc>Specifies how errors shall be handled when resolving field references with mismatching types
            </short_desc>
            <long_desc>
                Some source files contain invalid bytecode. As a consequence, resolving field references may fail due to
                mismatching types.
                In other words, the expected type in the field reference does not match the type of the actually
                declared field. With this
                option, the user can specify how Soot shall react to such issues.
            </long_desc>
            <value>
                <name>Fail</name>
                <alias>fail</alias>
                <short_desc>Raise an error when a field type mismatch is detected</short_desc>
                <long_desc>
                    When resolving a field reference and the expected type does not match the declared type of the
                    actual field,
                    an exception will be thrown.
                </long_desc>
            </value>
            <value>
                <name>Ignore</name>
                <alias>ignore</alias>
                <short_desc>Ignore field type mismatches</short_desc>
                <long_desc>
                    With this option, Soot will not check whether there is a mismatch between the requested and the
                    declared field
                    type. Instead, it will return the declared field with a matching name regardless of the field's
                    type. This means that
                    field reference resolving will never fail because of mismatching types, but the returned field might
                    not be what
                    the user code expects.
                </long_desc>
            </value>
            <value>
                <name>ReturnNull</name>
                <alias>null</alias>
                <short_desc>Return null in case of type mismatch</short_desc>
                <default/>
                <long_desc>
                    When resolving a field reference for which the declared field type and the expected type from the
                    reference do not
                    match, Soot will return null with this option. The user code that invokes getField() is responsible
                    for correctly
                    handling these null references.
                </long_desc>
            </value>
        </multiopt>

        <phaseopt>
            <name>Phase Options</name>
            <alias>p</alias>
            <alias>phase-option</alias>
            <set_arg_label>phase opt:val</set_arg_label>
            <short_desc>Set <var>phase</var>&apos;s <var>opt</var> option to
                <var>value</var>
            </short_desc>
            <long_desc>
                <p>
                    Set <var>phase</var>'s run-time option named <var>opt</var> to
                    <var>value</var>.
                </p>
                <p>
                    This is a mechanism for specifying phase-specific options to
                    different parts of Soot. See <var>Soot phase options</var> for
                    details about the available phases and options.
                </p>
            </long_desc>
            <phase>
                <name>Jimple Body Creation</name>
                <alias>jb</alias>
                <class>JBOptions</class>
                <short_desc>Creates a <tt>JimpleBody</tt> for each method
                </short_desc>
                <long_desc>
                    Jimple Body Creation creates a <tt>JimpleBody</tt> for each input
                    method, using either coffi, to read <tt>.class</tt> files, or the
                    jimple parser, to read <tt>.jimple</tt> files.
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>true</default>
                    <short_desc/>
                    <long_desc/>
                </boolopt>
                <boolopt>
                    <name>Use Original Names</name>
                    <alias>use-original-names</alias>
                    <default>false</default>
                    <short_desc/>
                    <long_desc>
                        Retain the original names for local variables when the source
                        includes those names. Otherwise, Soot gives variables generic
                        names based on their types.
                    </long_desc>
                </boolopt>
                <boolopt>
                    <name>Preserve source-level annotations</name>
                    <alias>preserve-source-annotations</alias>
                    <default>false</default>
                    <short_desc/>
                    <long_desc>
                        Preserves annotations of retention type SOURCE. (for
                        everything but package and local variable annotations)
                    </long_desc>
                </boolopt>
                <boolopt>
                    <name>Stabilize local names</name>
                    <alias>stabilize-local-names</alias>
                    <default>false</default>
                    <short_desc/>
                    <long_desc>
                        Make sure that local names are stable between runs. This requires re-normalizing all
                        local names after the standard transformations and then sorting them which can negatively
                        impact performance. This option automatically sets "sort-locals" in "jb.lns" during the
                        second re-normalization pass.
                    </long_desc>
                </boolopt>
                <sub_phase>
                    <name>Duplicate CatchAll Trap Remover</name>
                    <alias>jb.dtr</alias>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                    <short_desc>Reduces chains of catch-all traps</short_desc>
                    <long_desc>
                        This transformer detects cases in which the same code block is covered by two different
                        catch all traps with different exception handlers (A and B), and if there is at the
                        same time a third catch all trap that covers the second handler B and jumps to A, then
                        the second trap is unnecessary, because it is already covered by a combination of the
                        other two traps. This transformer removes the unnecessary trap.
                    </long_desc>
                </sub_phase>
                <sub_phase>
                    <name>Empty Switch Eliminator</name>
                    <alias>jb.ese</alias>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                    <short_desc>Removes empty switch statements</short_desc>
                    <long_desc>
                        The Empty Switch Eliminator detects and removes switch statements that have no data labels.
                        Instead, the code is transformed to contain a single jump statement to the default label.
                    </long_desc>
                </sub_phase>
                <sub_phase>
                    <name>Local Splitter</name>
                    <alias>jb.ls</alias>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                    <short_desc>Local splitter: one local per DU-UD web</short_desc>
                    <long_desc>
                        The Local Splitter identifies DU-UD webs for local variables and
                        introduces new variables so that each disjoint web is associated
                        with a single local.
                    </long_desc>
                </sub_phase>
                <sub_phase>
                    <name>Jimple Local Aggregator</name>
                    <alias>jb.a</alias>
                    <short_desc>Aggregator: removes some unnecessary copies</short_desc>
                    <long_desc>
                        <p>
                            The Jimple Local Aggregator removes some unnecessary copies by
                            combining local variables. Essentially, it finds definitions
                            which have only a single use and, if it is safe to do so, removes
                            the original definition after replacing the use with the
                            definition's right-hand side.
                        </p>
                        <p>
                            At this stage in <tt>JimpleBody</tt> construction, local
                            aggregation serves largely to remove the copies to and from stack
                            variables which simulate load and store instructions in the
                            original bytecode.
                        </p>
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                    <boolopt>
                        <name>Only Stack Locals</name>
                        <alias>only-stack-locals</alias>
                        <long_desc>
                            Only aggregate locals that represent stack locations in the
                            original bytecode. (Stack locals can be distinguished in Jimple
                            by the
                            <dollar/>
                            character with which their names begin.)
                        </long_desc>
                        <default>true</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Unused Local Eliminator</name>
                    <alias>jb.ule</alias>
                    <short_desc>Unused local eliminator</short_desc>
                    <long_desc>
                        The Unused Local Eliminator removes any unused locals from the
                        method.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <short_desc>Assigns types to locals</short_desc>
                    <long_desc>
                        The Type Assigner gives local variables types which will
                        accommodate the values stored in them over the course of the
                        method.
                    </long_desc>
                    <name>Type Assigner</name>
                    <class>JBTROptions</class>
                    <alias>jb.tr</alias>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                    <boolopt>
                        <name>Use older type assigner</name>
                        <alias>use-older-type-assigner</alias>
                        <default>false</default>
                        <short_desc>Enables the older type assigner</short_desc>
                        <long_desc>
                            This enables the older type assigner that was in use until May 2008.
                            The current type assigner is a reimplementation by Ben Bellamy
                            that uses an entirely new and faster algorithm which always assigns
                            the most narrow type possible. If compare-type-assigners is on,
                            this option causes the older type assigner to execute first.
                            (Otherwise the newer one is executed first.)
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>Compare type assigners</name>
                        <alias>compare-type-assigners</alias>
                        <default>false</default>
                        <short_desc>Compares Ben Bellamy's and the older type assigner</short_desc>
                        <long_desc>
                            Enables comparison (both runtime and results) of Ben Bellamy's type assigner with the
                            older type assigner that was in Soot.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>Ignore Nullpointer Dereferences</name>
                        <alias>ignore-nullpointer-dereferences</alias>
                        <default>false</default>
                        <short_desc>Ignores virtual method calls on base objects that may only be null</short_desc>
                        <long_desc>
                            If this option is enabled, Soot wiil not check whether the base object of a virtual method
                            call can only be null. This will lead to the null_type pseudo type being used in your Jimple
                            code.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Unsplit-originals Local Packer</name>
                    <alias>jb.ulp</alias>
                    <short_desc>Local packer: minimizes number of locals</short_desc>
                    <long_desc>
                        The Unsplit-originals Local Packer executes only when the
                        `<tt>use-original-names</tt>&apos; option is chosen for the
                        `<tt>jb</tt>&apos; phase. The Local Packer attempts to minimize
                        the number of local variables required in a method by reusing the
                        same variable for disjoint DU-UD webs. Conceptually, it is the
                        inverse of the Local Splitter.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Unsplit Original Locals</name>
                        <alias>unsplit-original-locals</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc>
                            Use the variable names in the original source as a guide when
                            determining how to share local variables among non-interfering
                            variable usages. This recombines named locals which were split by
                            the Local Splitter.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Local Name Standardizer</name>
                    <alias>jb.lns</alias>
                    <short_desc>Local name standardizer</short_desc>
                    <long_desc>
                        The Local Name Standardizer assigns generic names to local variables.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Only Stack Locals</name>
                        <alias>only-stack-locals</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc>
                            Only standardizes the names of variables that represent stack
                            locations in the original bytecode. This becomes the default when
                            the `<tt>use-original-names</tt>&apos; option is specified for
                            the `<tt>jb</tt>&apos; phase.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>Sort Locals</name>
                        <alias>sort-locals</alias>
                        <default>false</default>
                        <short_desc>
                            Specifies whether the locals shall be ordered.
                        </short_desc>
                        <long_desc>
                            First sorts the locals alphabetically by the string representation of
                            their type. Then if there are two locals with the same type, it uses
                            the only other source of structurally stable information (i.e. the
                            instructions themselves) to produce an ordering for the locals
                            that remains consistent between different soot instances. It achieves
                            this by determining the position of a local's first occurrence in the
                            instruction's list of definition statements. This position is then used
                            to sort the locals with the same type in an ascending order.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Copy Propagator</name>
                    <alias>jb.cp</alias>
                    <short_desc>Copy propagator</short_desc>
                    <long_desc>
                        This phase performs cascaded copy propagation.

                        If the propagator encounters situations of the form:
                        <pre>
                            A: a = ...;
                            ...
                            B: x = a;
                            ...
                            C: ... = ... x;
                        </pre>
                        where <tt>a</tt> and <tt>x</tt> are each defined only once (at
                        <tt>A</tt>
                        and <tt>B</tt>, respectively), then it can propagate
                        immediately without checking between <tt>B</tt> and
                        <tt>C</tt>
                        for redefinitions of <tt>a</tt>. In
                        this case the propagator is global.

                        Otherwise, if <tt>a</tt> has multiple definitions then the
                        propagator checks for redefinitions and propagates copies
                        only within extended basic blocks.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Only Regular Locals</name>
                        <alias>only-regular-locals</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc>
                            Only propagate copies through ``regular&apos;&apos; locals, that is,
                            those declared in the source bytecode.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>Only Stack Locals</name>
                        <alias>only-stack-locals</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc>
                            Only propagate copies through locals that represent stack locations in
                            the original bytecode.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Dead Assignment Eliminator</name>
                    <alias>jb.dae</alias>
                    <short_desc>Dead assignment eliminator</short_desc>
                    <long_desc>
                        The Dead Assignment Eliminator eliminates assignment statements
                        to locals whose values are not subsequently used, unless
                        evaluating the right-hand side of the assignment may cause
                        side-effects.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Only Stack Locals</name>
                        <alias>only-stack-locals</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc>
                            Only eliminate dead assignments to locals that represent stack
                            locations in the original bytecode.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Post-copy propagation Unused Local Eliminator</name>
                    <alias>jb.cp-ule</alias>
                    <short_desc>Post-copy propagation unused local eliminator</short_desc>
                    <long_desc>
                        This phase removes any locals that are unused after copy propagation.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Local Packer</name>
                    <alias>jb.lp</alias>
                    <short_desc>Local packer: minimizes number of locals</short_desc>
                    <long_desc>
                        The Local Packer attempts to minimize the number of local
                        variables required in a method by reusing the same variable for
                        disjoint DU-UD webs. Conceptually, it is the inverse of the
                        Local Splitter.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                    <boolopt>
                        <name>Unsplit Original Locals</name>
                        <alias>unsplit-original-locals</alias>
                        <default>false</default>
                        <long_desc>
                            Use the variable names in the original source as a guide when
                            determining how to share local variables across non-interfering
                            variable usages. This recombines named locals which were split by
                            the Local Splitter.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Nop Eliminator</name>
                    <alias>jb.ne</alias>
                    <short_desc>Nop eliminator</short_desc>
                    <long_desc>
                        The Nop Eliminator removes <tt>nop</tt> statements from the method.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Unreachable Code Eliminator</name>
                    <alias>jb.uce</alias>
                    <short_desc>Unreachable code eliminator</short_desc>
                    <long_desc>
                        The Unreachable Code Eliminator removes unreachable code and
                        traps whose catch blocks are empty.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                    <boolopt>
                        <name>Remove unreachable traps</name>
                        <alias>remove-unreachable-traps</alias>
                        <default>true</default>
                        <long_desc>
                            Remove exception table entries when none of the protected instructions can
                            throw the exception being caught.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Trap Tightener</name>
                    <alias>jb.tt</alias>
                    <short_desc>Trap Tightener</short_desc>
                    <long_desc>
                        The Trap Tightener changes the area protected by each exception handler,
                        so that it begins with the first instruction in the old protected
                        area which is actually capable of throwing an exception caught by the
                        handler, and ends just after the last instruction in the old
                        protected area which can throw an exception caught by the
                        handler. This reduces the chance of producing unverifiable code
                        as a byproduct of pruning exceptional control flow within CFGs.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                </sub_phase>
            </phase>
            <phase>
                <name>Java To Jimple Body Creation</name>
                <alias>jj</alias>
                <class>JJOptions</class>
                <short_desc>Creates a <tt>JimpleBody</tt> for each method directly from source
                </short_desc>
                <long_desc>
                    Jimple Body Creation creates a <tt>JimpleBody</tt> for each input
                    method, using polyglot, to read <tt>.java</tt> files.
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>true</default>
                    <short_desc/>
                    <long_desc/>
                </boolopt>
                <boolopt>
                    <name>Use Original Names</name>
                    <alias>use-original-names</alias>
                    <default>true</default>
                    <short_desc/>
                    <long_desc>
                        Retain the original names for local variables when the source
                        includes those names. Otherwise, Soot gives variables generic
                        names based on their types.
                    </long_desc>
                </boolopt>
                <sub_phase>
                    <name>Local Splitter</name>
                    <alias>jj.ls</alias>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                    <short_desc>Local splitter: one local per DU-UD web</short_desc>
                    <long_desc>
                        The Local Splitter identifies DU-UD webs for local variables and
                        introduces new variables so that each disjoint web is associated
                        with a single local.
                    </long_desc>
                </sub_phase>
                <sub_phase>
                    <name>Jimple Local Aggregator</name>
                    <alias>jj.a</alias>
                    <short_desc>Aggregator: removes some unnecessary copies</short_desc>
                    <long_desc>
                        <p>
                            The Jimple Local Aggregator removes some unnecessary copies by
                            combining local variables. Essentially, it finds definitions
                            which have only a single use and, if it is safe to do so, removes
                            the original definition after replacing the use with the
                            definition's right-hand side.
                        </p>
                        <p>
                            At this stage in <tt>JimpleBody</tt> construction, local
                            aggregation serves largely to remove the copies to and from stack
                            variables which simulate load and store instructions in the
                            original bytecode.
                        </p>
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                    <boolopt>
                        <name>Only Stack Locals</name>
                        <alias>only-stack-locals</alias>
                        <long_desc>
                            Only aggregate locals that represent stack locations in the
                            original bytecode. (Stack locals can be distinguished in Jimple
                            by the
                            <dollar/>
                            character with which their names begin.)
                        </long_desc>
                        <default>true</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Unused Local Eliminator</name>
                    <alias>jj.ule</alias>
                    <short_desc>Unused local eliminator</short_desc>
                    <long_desc>
                        The Unused Local Eliminator removes any unused locals from the
                        method.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <short_desc>Assigns types to locals</short_desc>
                    <long_desc>
                        The Type Assigner gives local variables types which will
                        accommodate the values stored in them over the course of the
                        method.
                    </long_desc>
                    <name>Type Assigner</name>
                    <alias>jj.tr</alias>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Unsplit-originals Local Packer</name>
                    <alias>jj.ulp</alias>
                    <short_desc>Local packer: minimizes number of locals</short_desc>
                    <long_desc>
                        The Unsplit-originals Local Packer executes only when the
                        `<tt>use-original-names</tt>&apos; option is chosen for the
                        `<tt>jb</tt>&apos; phase. The Local Packer attempts to minimize
                        the number of local variables required in a method by reusing the
                        same variable for disjoint DU-UD webs. Conceptually, it is the
                        inverse of the Local Splitter.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Unsplit Original Locals</name>
                        <alias>unsplit-original-locals</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc>
                            Use the variable names in the original source as a guide when
                            determining how to share local variables among non-interfering
                            variable usages. This recombines named locals which were split by
                            the Local Splitter.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Local Name Standardizer</name>
                    <alias>jj.lns</alias>
                    <short_desc>Local name standardizer</short_desc>
                    <long_desc>
                        The Local Name Standardizer assigns generic names to local variables.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Only Stack Locals</name>
                        <alias>only-stack-locals</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc>
                            Only standardizes the names of variables that represent stack
                            locations in the original bytecode. This becomes the default when
                            the `<tt>use-original-names</tt>&apos; option is specified for
                            the `<tt>jb</tt>&apos; phase.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Copy Propagator</name>
                    <alias>jj.cp</alias>
                    <short_desc>Copy propagator</short_desc>
                    <long_desc>
                        This phase performs cascaded copy propagation.

                        If the propagator encounters situations of the form:
                        <pre>
                            A: a = ...;
                            ...
                            B: x = a;
                            ...
                            C: ... = ... x;
                        </pre>
                        where <tt>a</tt> and <tt>x</tt> are each defined only once (at
                        <tt>A</tt>
                        and <tt>B</tt>, respectively), then it can propagate
                        immediately without checking between <tt>B</tt> and
                        <tt>C</tt>
                        for redefinitions of <tt>a</tt>. In
                        this case the propagator is global.

                        Otherwise, if <tt>a</tt> has multiple definitions then the
                        propagator checks for redefinitions and propagates copies
                        only within extended basic blocks.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Only Regular Locals</name>
                        <alias>only-regular-locals</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc>
                            Only propagate copies through ``regular&apos;&apos; locals, that is,
                            those declared in the source bytecode.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>Only Stack Locals</name>
                        <alias>only-stack-locals</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc>
                            Only propagate copies through locals that represent stack locations in
                            the original bytecode.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Dead Assignment Eliminator</name>
                    <alias>jj.dae</alias>
                    <short_desc>Dead assignment eliminator</short_desc>
                    <long_desc>
                        The Dead Assignment Eliminator eliminates assignment statements
                        to locals whose values are not subsequently used, unless
                        evaluating the right-hand side of the assignment may cause
                        side-effects.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Only Stack Locals</name>
                        <alias>only-stack-locals</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc>
                            Only eliminate dead assignments to locals that represent stack
                            locations in the original bytecode.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Post-copy propagation Unused Local Eliminator</name>
                    <alias>jj.cp-ule</alias>
                    <short_desc>Post-copy propagation unused local eliminator</short_desc>
                    <long_desc>
                        This phase removes any locals that are unused after copy propagation.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Local Packer</name>
                    <alias>jj.lp</alias>
                    <short_desc>Local packer: minimizes number of locals</short_desc>
                    <long_desc>
                        The Local Packer attempts to minimize the number of local
                        variables required in a method by reusing the same variable for
                        disjoint DU-UD webs. Conceptually, it is the inverse of the
                        Local Splitter.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                    <boolopt>
                        <name>Unsplit Original Locals</name>
                        <alias>unsplit-original-locals</alias>
                        <default>false</default>
                        <long_desc>
                            Use the variable names in the original source as a guide when
                            determining how to share local variables across non-interfering
                            variable usages. This recombines named locals which were split by
                            the Local Splitter.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Nop Eliminator</name>
                    <alias>jj.ne</alias>
                    <short_desc>Nop eliminator</short_desc>
                    <long_desc>
                        The Nop Eliminator removes <tt>nop</tt> statements from the method.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Unreachable Code Eliminator</name>
                    <alias>jj.uce</alias>
                    <short_desc>Unreachable code eliminator</short_desc>
                    <long_desc>
                        The Unreachable Code Eliminator removes unreachable code and
                        traps whose catch blocks are empty.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                </sub_phase>
            </phase>
            <phase>
                <name>Whole Jimple Pre-processing Pack</name>
                <alias>wjpp</alias>
                <short_desc>Whole Jimple Pre-processing Pack</short_desc>
                <long_desc>
                    <p>
                        This pack allows you to insert pre-processors that are run before
                        call-graph construction. Only enabled in whole-program mode.
                    </p>
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>true</default>
                </boolopt>
                <sub_phase>
                    <name>Constant reflective method invocation base transformer</name>
                    <alias>wjpp.cimbt</alias>
                    <short_desc>Replaces base objects of calls to Method.invoke() that are string constants by locals
                    </short_desc>
                    <long_desc>When using the <tt>types-for-invoke</tt> option of the <b>cg</b> phase, problems might
                        occur if the base object of a call to Method.invoke() (the first argument) is a string constant.
                        This option replaces all
                        string constants of such calls by locals and, therefore, allows the
                        static resolution of reflective call targets on constant string objects.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                    <boolopt>
                        <name>Verbose</name>
                        <alias>verbose</alias>
                        <default>false</default>
                    </boolopt>
                </sub_phase>
            </phase>
            <phase>
                <name>Whole Shimple Pre-processing Pack</name>
                <alias>wspp</alias>
                <short_desc>Whole Shimple Pre-processing Pack</short_desc>
                <long_desc>
                    <p>
                        This pack allows you to insert pre-processors that are run before
                        call-graph construction. Only enabled in whole-program Shimple mode.
                    </p>
                    <p>
                        In an unmodified copy of Soot, this pack is empty.
                    </p>
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>true</default>
                </boolopt>
            </phase>
            <radio_phase>
                <name>Call Graph Constructor</name>
                <alias>cg</alias>
                <class>CGOptions</class>
                <short_desc>Call graph constructor</short_desc>
                <long_desc>
                    The Call Graph Constructor computes a call graph for whole
                    program analysis. When this pack finishes, a call graph is
                    available in the Scene. The different phases in this pack are
                    different ways to construct the call graph. Exactly one phase in
                    this pack must be enabled; Soot will raise an error otherwise.
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>true</default>
                </boolopt>
                <boolopt>
                    <name>Safe forName</name>
                    <alias>safe-forname</alias>
                    <default>false</default>
                    <short_desc>Handle Class.forName() calls conservatively</short_desc>
                    <long_desc>When a program calls
                        Class.forName(), the named class is resolved, and its static initializer
                        executed. In many cases, it cannot be determined statically which
                        class will be loaded, and which static initializer executed. When this
                        option is set to true, Soot will conservatively assume that any static
                        initializer could be executed. This may make the call graph very large.
                        When this option is set to false, any calls to Class.forName() for which
                        the class cannot be determined statically are assumed to call no
                        static initializers.
                    </long_desc>
                </boolopt>
                <boolopt>
                    <name>Safe newInstance</name>
                    <alias>safe-newinstance</alias>
                    <default>false</default>
                    <short_desc>Handle Class.newInstance() calls conservatively</short_desc>
                    <long_desc>When a program calls
                        Class.newInstance(), a new object is created and its constructor
                        executed. Soot does not determine statically which
                        type of object will be created, and which constructor executed. When this
                        option is set to true, Soot will conservatively assume that any constructor
                        could be executed. This may make the call graph very large.
                        When this option is set to false, any calls to Class.newInstance()
                        are assumed not to call the constructor of the created object.
                    </long_desc>
                </boolopt>
                <multiopt>
                    <name>Library mode</name>
                    <alias>library</alias>
                    <short_desc>
                        Specifies whether the target classes should be treated as an application or a library.
                    </short_desc>
                    <long_desc>
                        Specifies whether the target classes should be treated as an application or a library.
                        If library mode is disabled (default), the call graph construction assumes that
                        the target is an application and
                        starts the construction from the specified entry points (main method by
                        default).
                        Under the assumption that the target is a library, possible call edges might be missing in the
                        call graph.
                        The two different library modes add theses missing calls to the call graph and
                        differ only in the view of the class hierachy
                        (hierachy of target library or possible extended hierachy).
                        If simulate-natives is also set, the results of native methods are also set to any sub type of
                        the declared return type.
                    </long_desc>
                    <value>
                        <name>Disabled</name>
                        <alias>disabled</alias>
                        <default/>
                        <short_desc>
                            Call(and pointer assignment) graph construction treat the target classes as application
                            starting from the entry points.
                        </short_desc>
                        <long_desc>
                            Call(and pointer assignment) graph construction treat the target classes as application
                            starting from the entry points.
                        </long_desc>
                    </value>
                    <value>
                        <name>Any Subtype</name>
                        <alias>any-subtype</alias>
                        <short_desc>
                            In this mode types of any accessible field, method parameter, this local, or
                            caugth exception is set to any possible sub type
                            according to the class hierarchy of the target library.
                        </short_desc>
                        <long_desc>
                            On library analysis it has to be assumed, that a possible client can call
                            any method or access any field,
                            to which he has the access rights (default public/protected but can be set with
                            soot.Scene#setClientAccessibilityOracle).
                            In this mode types of any accessible field, method parameter, this local, or
                            caugth exception is set to any possible sub type
                            according to the class hierachy of the target library.
                            If simulate-natives is also set, the results of native methods are also set to any sub type
                            of the declared return type.
                        </long_desc>
                    </value>
                    <value>
                        <name>By Signature resolution</name>
                        <alias>signature-resolution</alias>
                        <short_desc>
                            In this mode types of any accessible field, method parameter, this local, or
                            caugth exception is set to any possible sub type
                            according to a possible extended class hierarchy of the target library.
                        </short_desc>
                        <long_desc>
                            On library analysis it has to be assumed, that a possible client can call
                            any method or access any field,
                            to which he has the access rights (default public/protected but can be set with
                            soot.Scene#setClientAccessibilityOracle).
                            In this mode types of any accessible field, method parameter, this local, or
                            caugth exception is set to any possible sub type
                            according to a possible extended class hierarchy of the target library.
                            Whenever any sub type of a specific type is considered as
                            receiver for a method to call and the base type is an interface, calls to
                            existing methods with matching signature (possible implementation
                            of method to call) are also added. As Javas' subtyping allows
                            contra-variance for return types and co-variance for parameters when
                            overriding
                            a method, these cases are also considered here.

                            Example: Classes A, B (B sub type of A), interface I with method public A foo(B b); and a
                            class C with method public B foo(A a) { ... }.
                            The extended class hierachy will contain C as possible implementation of I.

                            If simulate-natives is also set, the results of native methods are also set to any possible
                            sub type of the declared return type.
                        </long_desc>
                    </value>
                </multiopt>
                <boolopt>
                    <name>Verbose</name>
                    <alias>verbose</alias>
                    <default>false</default>
                    <short_desc>Print warnings about where the call graph may be incomplete</short_desc>
                    <long_desc>Due to the effects of native methods and reflection, it may not always be possible to
                        construct a fully conservative call graph. Setting this option to true causes Soot to point out
                        the parts of the call graph that may be incomplete, so that they can be checked by hand.
                    </long_desc>
                </boolopt>
                <intopt>
                    <name>JDK version</name>
                    <alias>jdkver</alias>
                    <default>3</default>
                    <short_desc>JDK version for native methods</short_desc>
                    <long_desc>This option sets the JDK version of the standard library being analyzed so that Soot can
                        simulate the native methods in the specific version of the library. The default, 3, refers to
                        Java 1.3.x.
                    </long_desc>
                </intopt>
                <boolopt>
                    <name>All Application Class Methods Reachable</name>
                    <alias>all-reachable</alias>
                    <default>false</default>
                    <short_desc>Assume all methods of application classes are reachable.</short_desc>
                    <long_desc>When this option is false, the call graph is built starting at a set of entry points, and
                        only methods reachable from those entry points are processed. Unreachable methods will not have
                        any call graph edges generated out of them. Setting this option to true makes Soot consider all
                        methods of application classes to be reachable, so call edges are generated for all of them.
                        This leads to a larger call graph. For program visualization purposes, it is sometimes desirable
                        to include edges from unreachable methods; although these methods are unreachable in the version
                        being analyzed, they may become reachable if the program is modified.
                    </long_desc>
                </boolopt>
                <boolopt>
                    <name>Implicit Entry Points</name>
                    <alias>implicit-entry</alias>
                    <default>true</default>
                    <short_desc>Include methods called implicitly by the VM as entry points</short_desc>
                    <long_desc>When this option is true, methods that are called implicitly by the VM are considered
                        entry points of the call graph. When it is false, these methods are not considered entry points,
                        leading to a possibly incomplete call graph.
                    </long_desc>
                </boolopt>
                <boolopt>
                    <name>Trim Static Initializer Edges</name>
                    <alias>trim-clinit</alias>
                    <default>true</default>
                    <short_desc>Removes redundant static initializer calls</short_desc>
                    <long_desc>The call graph contains an edge
                        from each statement that could trigger execution of a static initializer to that
                        static initializer. However, each static initializer is triggered only once.
                        When this option is enabled, after the call graph is built, an intra-procedural
                        analysis is performed to detect static initializer edges leading to methods
                        that must have already been executed. Since these static initializers cannot be
                        executed again, the corresponding call graph edges are removed from the call graph.
                    </long_desc>
                </boolopt>
                <stropt>
                    <name>Reflection Log</name>
                    <alias>reflection-log</alias>
                    <short_desc>Uses a reflection log to resolve reflective calls.</short_desc>
                    <long_desc>Load a reflection log
                        from the given file and use this log to resolve reflective call sites. Note that
                        when a log is given, the following other options have no effect: safe-forname,
                        safe-newinstance.
                    </long_desc>
                </stropt>
                <stropt>
                    <name>Guarding strategy</name>
                    <alias>guards</alias>
                    <default>ignore</default>
                    <short_desc>Describes how to guard the program from unsound assumptions.</short_desc>
                    <long_desc>Using a reflection log is only sound for method executions that were logged.
                        Executing the program differently may be unsound. Soot can insert guards at program points for
                        which the reflection log
                        contains no information. When these points are reached (because the program is executed
                        differently) then the follwing will happen,
                        depending on the value of this flag. ignore: no guard is inserted, the program executes normally
                        but under unsound assumptions.
                        print: the program prints a stack trace when reaching a porgram location that was not traced but
                        continues to run. throw (default):
                        the program throws an Error instead.
                    </long_desc>
                </stropt>
                <boolopt>
                    <name>Types for invoke</name>
                    <alias>types-for-invoke</alias>
                    <default>false</default>
                    <short_desc>Uses reaching types inferred by the pointer analysis to resolve reflective calls.
                    </short_desc>
                    <long_desc>For each call to Method.invoke(), use the possible types of the first receiver
                        argument and the possible types stored in the second argument array to resolve calls to
                        Method.invoke(). This strategy makes no attempt to resolve reflectively invoked static methods.
                        Currently only works for context insensitive pointer analyses.
                    </long_desc>
                </boolopt>
                <sub_phase>
                    <name>Class Hierarchy Analysis</name>
                    <alias>cg.cha</alias>
                    <class>CHAOptions</class>
                    <short_desc>Builds call graph using Class Hierarchy Analysis</short_desc>
                    <long_desc>This phase uses Class Hierarchy Analysis to generate a call graph.</long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                    <boolopt>
                        <name>Verbose</name>
                        <alias>verbose</alias>
                        <default>false</default>
                        <short_desc>Print statistics about the resulting call graph</short_desc>
                        <long_desc>Setting this option to true causes Soot to print out statistics about the call graph
                            computed by this phase, such as the number of methods determined to be reachable.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>AppOnly</name>
                        <alias>apponly</alias>
                        <default>false</default>
                        <short_desc>Consider only application classes</short_desc>
                        <long_desc>Setting this option to true causes Soot to only consider application classes when
                            building the callgraph. The resulting callgraph will be inherently unsound. Still, this
                            option can make sense if performance optimization and memory reduction are your primary
                            goal.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Spark</name>
                    <class>SparkOptions</class>
                    <alias>cg.spark</alias>
                    <short_desc>Spark points-to analysis framework</short_desc>
                    <long_desc>Spark is a flexible points-to analysis framework. Aside from building a call graph, it
                        also generates information about the targets of pointers. For details about Spark, please see <a
                                href="http://www.sable.mcgill.ca/publications/thesis/#olhotakMastersThesis">Ondrej
                            Lhotak's M.Sc. thesis</a>.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <section>
                        <name>Spark General Options</name>
                        <boolopt>
                            <name>Verbose</name>
                            <alias>verbose</alias>
                            <default>false</default>
                            <short_desc>Print detailed information about the execution of Spark</short_desc>
                            <long_desc>
                                When this option is set to true, Spark prints detailed information about its execution.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Ignore Types Entirely</name>
                            <alias>ignore-types</alias>
                            <default>false</default>
                            <short_desc>Make Spark completely ignore declared types of variables</short_desc>
                            <long_desc>
                                When this option is set to true, all parts of Spark completely ignore
                                declared types of variables and casts.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Force Garbage Collections</name>
                            <alias>force-gc</alias>
                            <default>false</default>
                            <short_desc>Force garbage collection for measuring memory usage</short_desc>
                            <long_desc>
                                When this option is set to true, calls to System.gc() will be made at
                                various points to allow memory usage to be measured.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Pre Jimplify</name>
                            <alias>pre-jimplify</alias>
                            <default>false</default>
                            <short_desc>Jimplify all methods before starting Spark</short_desc>
                            <long_desc>
                                When this option is set to true, Spark converts all available methods to Jimple
                                before starting the points-to analysis. This allows the Jimplification
                                time to be separated from the points-to time. However, it increases the
                                total time and memory requirement, because all methods are Jimplified,
                                rather than only those deemed reachable by the points-to analysis.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>AppOnly</name>
                            <alias>apponly</alias>
                            <default>false</default>
                            <short_desc>Consider only application classes</short_desc>
                            <long_desc>Setting this option to true causes Soot to only consider application classes when
                                building the callgraph. The resulting callgraph will be inherently unsound. Still, this
                                option can make sense if performance optimization and memory reduction are your primary
                                goal.
                            </long_desc>
                        </boolopt>
                    </section>
                    <section>
                        <name>Spark Pointer Assignment Graph Building Options</name>
                        <boolopt>
                            <name>VTA</name>
                            <alias>vta</alias>
                            <default>false</default>
                            <short_desc>Emulate Variable Type Analysis</short_desc>
                            <long_desc>
                                Setting VTA to true has the effect of setting field-based,
                                types-for-sites, and simplify-sccs to true, and on-fly-cg to false,
                                to simulate Variable Type
                                Analysis, described in <a
                                    href="http://www.sable.mcgill.ca/publications/papers/#oopsla2000">our OOPSLA 2000
                                paper</a>. Note that the
                                algorithm differs from the original VTA in that it handles array
                                elements more precisely.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>RTA</name>
                            <alias>rta</alias>
                            <default>false</default>
                            <short_desc>Emulate Rapid Type Analysis</short_desc>
                            <long_desc>
                                Setting RTA to true sets types-for-sites to true, and causes Spark to use
                                a single points-to set for all variables, giving <a
                                    href="http://doi.acm.org/10.1145/236337.236371">Rapid Type
                                Analysis</a>.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Field Based</name>
                            <alias>field-based</alias>
                            <default>false</default>
                            <short_desc>Use a field-based rather than field-sensitive representation</short_desc>
                            <long_desc>
                                When this option is set to true, fields are represented by variable
                                (Green) nodes, and the object that the field belongs to is ignored
                                (all objects are lumped together), giving a field-based analysis. Otherwise, fields are
                                represented by
                                field reference (Red) nodes, and the objects that they belong to are
                                distinguished, giving a field-sensitive analysis.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Types For Sites</name>
                            <alias>types-for-sites</alias>
                            <default>false</default>
                            <short_desc>Represent objects by their actual type rather than allocation site</short_desc>
                            <long_desc>
                                When this option is set to true, types rather than allocation sites are
                                used as the elements of the points-to sets.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Merge String Buffer</name>
                            <alias>merge-stringbuffer</alias>
                            <default>true</default>
                            <short_desc>Represent all StringBuffers as one object</short_desc>
                            <long_desc>
                                When this option is set to true, all allocation sites creating
                                <tt>java.lang.StringBuffer</tt>
                                objects are grouped together as a single
                                allocation site.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Propagate All String Constants</name>
                            <alias>string-constants</alias>
                            <default>false</default>
                            <short_desc>Propagate all string constants, not just class names</short_desc>
                            <long_desc>
                                When this option is set to false, Spark only distinguishes string constants that
                                may be the name of a class loaded dynamically using reflection, and all other
                                string constants are lumped together into a single string constant node.
                                Setting this option to true causes all string constants to be propagated
                                individually.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Simulate Natives</name>
                            <alias>simulate-natives</alias>
                            <default>true</default>
                            <short_desc>Simulate effects of native methods in standard class library</short_desc>
                            <long_desc>
                                When this option is set to true, the effects of native methods in the standard Java
                                class library are simulated.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Treat EMPTY as Alloc</name>
                            <alias>empties-as-allocs</alias>
                            <default>false</default>
                            <short_desc>Treat singletons for empty sets etc. as allocation sites</short_desc>
                            <long_desc>
                                When this option is set to true, Spark treats references to <code>
                                EMPTYSET</code>, <code>EMPTYMAP</code>, and
                                <code>EMPTYLIST</code>
                                as allocation sites for <code>HashSet</code>, <code>HashMap</code> and <code>
                                LinkedList
                            </code> objects respectively, and references to <code>Hashtable.emptyIterator</code> as
                                allocation sites for <code>Hashtable.EmptyIterator</code>. This enables subsequent
                                analyses to differentiate different uses of Java's immutable empty collections.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Simple Edges Bidirectional</name>
                            <alias>simple-edges-bidirectional</alias>
                            <default>false</default>
                            <short_desc>Equality-based analysis between variable nodes</short_desc>
                            <long_desc>
                                When this option is set to true, all edges connecting variable (Green)
                                nodes are made bidirectional, as in <a href="http://doi.acm.org/10.1145/237721.237727">
                                Steensgaard&apos;s analysis</a>.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>On Fly Call Graph</name>
                            <alias>on-fly-cg</alias>
                            <default>true</default>
                            <short_desc>Build call graph as receiver types become known</short_desc>
                            <long_desc>
                                When this option is set to true, the call graph is computed on-the-fly
                                as points-to information is computed. Otherwise, an initial
                                CHA approximation to the call graph is used.
                            </long_desc>
                        </boolopt>
                    </section>
                    <section>
                        <name>Spark Pointer Assignment Graph Simplification Options</name>
                        <boolopt>
                            <name>Simplify Offline</name>
                            <alias>simplify-offline</alias>
                            <default>false</default>
                            <short_desc>Collapse single-entry subgraphs of the PAG</short_desc>
                            <long_desc>
                                When this option is set to true, variable (Green) nodes which form
                                single-entry subgraphs (so they must have the same points-to set) are
                                merged before propagation begins.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Simplify SCCs</name>
                            <alias>simplify-sccs</alias>
                            <default>false</default>
                            <short_desc>Collapse strongly-connected components of the PAG</short_desc>
                            <long_desc>
                                When this option is set to true, variable (Green) nodes which form
                                strongly-connected components (so they must have the same points-to set)
                                are merged before propagation begins.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Ignore Types For SCCs</name>
                            <alias>ignore-types-for-sccs</alias>
                            <default>false</default>
                            <short_desc>Ignore declared types when determining node equivalence for SCCs</short_desc>
                            <long_desc>
                                When this option is set to true, when collapsing strongly-connected
                                components, nodes forming SCCs are collapsed regardless of their declared type.
                                The collapsed SCC is given the most general type of all the nodes in the
                                component.

                                When this option is set to false, only edges connecting nodes of the
                                same type are considered when detecting SCCs.

                                This option has no effect unless <tt>simplify-sccs</tt> is true.
                            </long_desc>
                        </boolopt>
                    </section>
                    <section>
                        <name>Spark Points-To Set Flowing Options</name>
                        <multiopt>
                            <name>Propagator</name>
                            <alias>propagator</alias>
                            <value>
                                <name>Iter</name>
                                <alias>iter</alias>
                                <short_desc>Simple iterative algorithm</short_desc>
                                <long_desc>
                                    Iter is a simple, iterative algorithm, which propagates everything until the
                                    graph does not change.
                                </long_desc>
                            </value>
                            <value>
                                <name>Worklist</name>
                                <alias>worklist</alias>
                                <default/>
                                <short_desc>Fast, worklist-based algorithm</short_desc>
                                <long_desc>
                                    Worklist is a worklist-based algorithm that tries
                                    to do as little work as possible. This is currently the fastest algorithm.
                                </long_desc>

                            </value>
                            <value>
                                <name>Cycle</name>
                                <alias>cycle</alias>
                                <short_desc>Unfinished on-the-fly cycle detection algorithm</short_desc>
                                <long_desc>This algorithm finds cycles in the PAG on-the-fly. It is not yet finished.
                                </long_desc>
                            </value>
                            <value>
                                <name>Merge</name>
                                <alias>merge</alias>
                                <short_desc>Unfinished field reference merging algorithms</short_desc>
                                <long_desc>
                                    Merge is an algorithm that merges all concrete field (yellow) nodes with their
                                    corresponding
                                    field reference (red) nodes. This algorithm is not yet finished.
                                </long_desc>
                            </value>
                            <value>
                                <name>Alias</name>
                                <alias>alias</alias>
                                <short_desc>Alias-edge based algorithm</short_desc>
                                <long_desc>
                                    Alias is an alias-edge based algorithm. This algorithm tends to take
                                    the least memory for very large problems, because it does not represent
                                    explicitly points-to sets of fields of heap objects.
                                </long_desc>

                            </value>
                            <value>
                                <name>None</name>
                                <alias>none</alias>
                                <short_desc>Disable propagation</short_desc>
                                <long_desc>
                                    None means that propagation is not done; the graph is only built and
                                    simplified. This is useful if an external solver is being used to perform the
                                    propagation.
                                </long_desc>
                            </value>
                            <short_desc>Select propagation algorithm</short_desc>
                            <long_desc>
                                This option tells Spark which propagation algorithm to use.
                            </long_desc>
                        </multiopt>
                        <multiopt>
                            <name>Set Implementation</name>
                            <alias>set-impl</alias>
                            <value>
                                <name>Hash set</name>
                                <alias>hash</alias>
                                <short_desc>Use Java HashSet</short_desc>

                                <long_desc>
                                    Hash is an implementation based on Java&apos;s built-in hash-set.
                                </long_desc>
                            </value>
                            <value>
                                <name>Bit-vector</name>
                                <alias>bit</alias>
                                <short_desc>Bit vector</short_desc>
                                <long_desc>
                                    Bit is an implementation using a bit vector.
                                </long_desc>
                            </value>
                            <value>
                                <name>Hybrid</name>
                                <alias>hybrid</alias>
                                <short_desc>Hybrid representation using bit vector for large sets</short_desc>
                                <long_desc>
                                    Hybrid is an implementation that keeps an explicit list of up to
                                    16 elements, and switches to a bit-vector when the set gets
                                    larger than this.
                                </long_desc>
                            </value>
                            <value>
                                <name>Sorted array</name>
                                <alias>array</alias>
                                <short_desc>Sorted array representation</short_desc>
                                <long_desc>
                                    Array is an implementation that keeps the elements of the
                                    points-to set in a sorted array. Set membership is tested using
                                    binary search, and set union and intersection are computed using
                                    an algorithm based on the merge step from merge sort.
                                </long_desc>
                            </value>
                            <value>
                                <name>Heintze</name>
                                <alias>heintze</alias>
                                <short_desc>Heintze's shared bit-vector and overflow list representation</short_desc>
                                <long_desc>Heintze's representation has elements represented by a bit-vector + a small
                                    'overflow' list of some maximum number of elements. The bit-vectors can be shared
                                    by multiple points-to sets, while the overflow lists are not.
                                </long_desc>
                            </value>
                            <value>
                                <name>Shared List</name>
                                <alias>sharedlist</alias>
                                <short_desc>Shared list representation</short_desc>
                                <long_desc>Shared List stores its elements in a linked list, and might share
                                    its tail with other similar points-to sets.
                                </long_desc>
                            </value>
                            <value>
                                <name>Double</name>
                                <alias>double</alias>
                                <default/>
                                <short_desc>Double set representation for incremental propagation</short_desc>
                                <long_desc>
                                    Double is an implementation that itself uses a pair of sets for
                                    each points-to set. The first set in the pair stores new pointed-to
                                    objects that have not yet been propagated, while the second set stores
                                    old pointed-to objects that have been propagated and need not be
                                    reconsidered. This allows the propagation algorithms to be incremental,
                                    often speeding them up significantly.
                                </long_desc>
                            </value>
                            <short_desc>Select points-to set implementation</short_desc>
                            <long_desc>
                                Select an implementation of points-to sets for Spark to use.
                            </long_desc>
                        </multiopt>
                        <multiopt>
                            <name>Double Set Old</name>
                            <alias>double-set-old</alias>
                            <value>
                                <name>Hash set</name>
                                <alias>hash</alias>
                                <short_desc>Use Java HashSet</short_desc>

                                <long_desc>
                                    Hash is an implementation based on Java&apos;s built-in hash-set.
                                </long_desc>
                            </value>
                            <value>
                                <name>Bit-vector</name>
                                <alias>bit</alias>
                                <short_desc>Bit vector</short_desc>
                                <long_desc>
                                    Bit is an implementation using a bit vector.
                                </long_desc>
                            </value>
                            <value>
                                <name>Hybrid</name>
                                <alias>hybrid</alias>
                                <default/>
                                <short_desc>Hybrid representation using bit vector for large sets</short_desc>
                                <long_desc>
                                    Hybrid is an implementation that keeps an explicit list of up to
                                    16 elements, and switches to a bit-vector when the set gets
                                    larger than this.
                                </long_desc>
                            </value>
                            <value>
                                <name>Sorted array</name>
                                <alias>array</alias>
                                <short_desc>Sorted array representation</short_desc>
                                <long_desc>
                                    Array is an implementation that keeps the elements of the
                                    points-to set in a sorted array. Set membership is tested using
                                    binary search, and set union and intersection are computed using
                                    an algorithm based on the merge step from merge sort.
                                </long_desc>
                            </value>
                            <value>
                                <name>Heintze</name>
                                <alias>heintze</alias>
                                <short_desc>Heintze's shared bit-vector and overflow list representation</short_desc>
                                <long_desc>Heintze's representation has elements represented by a bit-vector + a small
                                    'overflow' list of some maximum number of elements. The bit-vectors can be shared
                                    by multiple points-to sets, while the overflow lists are not.
                                </long_desc>
                            </value>
                            <value>
                                <name>Shared List</name>
                                <alias>sharedlist</alias>
                                <short_desc>Shared list representation</short_desc>
                                <long_desc>Shared List stores its elements in a linked list, and might share
                                    its tail with other similar points-to sets.
                                </long_desc>
                            </value>
                            <short_desc>Select implementation of points-to set for old part of double set</short_desc>
                            <long_desc>
                                Select an implementation for sets of old objects in the double
                                points-to set implementation.

                                This option has no effect unless Set Implementation is set to double.
                            </long_desc>
                        </multiopt>
                        <multiopt>
                            <name>Double Set New</name>
                            <alias>double-set-new</alias>
                            <value>
                                <name>Hash set</name>
                                <alias>hash</alias>
                                <short_desc>Use Java HashSet</short_desc>

                                <long_desc>
                                    Hash is an implementation based on Java&apos;s built-in hash-set.
                                </long_desc>
                            </value>
                            <value>
                                <name>Bit-vector</name>
                                <alias>bit</alias>
                                <short_desc>Bit vector</short_desc>
                                <long_desc>
                                    Bit is an implementation using a bit vector.
                                </long_desc>
                            </value>
                            <value>
                                <name>Hybrid</name>
                                <alias>hybrid</alias>
                                <default/>
                                <short_desc>Hybrid representation using bit vector for large sets</short_desc>
                                <long_desc>
                                    Hybrid is an implementation that keeps an explicit list of up to
                                    16 elements, and switches to a bit-vector when the set gets
                                    larger than this.
                                </long_desc>
                            </value>
                            <value>
                                <name>Sorted array</name>
                                <alias>array</alias>
                                <short_desc>Sorted array representation</short_desc>
                                <long_desc>
                                    Array is an implementation that keeps the elements of the
                                    points-to set in a sorted array. Set membership is tested using
                                    binary search, and set union and intersection are computed using
                                    an algorithm based on the merge step from merge sort.
                                </long_desc>
                            </value>
                            <value>
                                <name>Heintze</name>
                                <alias>heintze</alias>
                                <short_desc>Heintze's shared bit-vector and overflow list representation</short_desc>
                                <long_desc>Heintze's representation has elements represented by a bit-vector + a small
                                    'overflow' list of some maximum number of elements. The bit-vectors can be shared
                                    by multiple points-to sets, while the overflow lists are not.
                                </long_desc>
                            </value>
                            <value>
                                <name>Shared List</name>
                                <alias>sharedlist</alias>
                                <short_desc>Shared list representation</short_desc>
                                <long_desc>Shared List stores its elements in a linked list, and might share
                                    its tail with other similar points-to sets.
                                </long_desc>
                            </value>
                            <short_desc>Select implementation of points-to set for new part of double set</short_desc>
                            <long_desc>
                                Select an implementation for sets of new objects in the double
                                points-to set implementation.

                                This option has no effect unless Set Implementation is set to double.
                            </long_desc>
                        </multiopt>
                    </section>
                    <section>
                        <name>Spark Output Options</name>
                        <boolopt>
                            <name>Dump HTML</name>
                            <alias>dump-html</alias>
                            <default>false</default>
                            <short_desc>Dump pointer assignment graph to HTML for debugging</short_desc>
                            <long_desc>
                                When this option is set to true, a browseable HTML representation of the
                                pointer assignment graph is output to a file called <tt>pag.jar</tt> after the analysis
                                completes. Note
                                that this representation is typically very large.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Dump PAG</name>
                            <alias>dump-pag</alias>
                            <default>false</default>
                            <short_desc>Dump pointer assignment graph for other solvers</short_desc>
                            <long_desc>
                                When this option is set to true, a representation of the pointer assignment graph
                                suitable for processing with other solvers (such as the BDD-based solver) is
                                output before the analysis begins.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Dump Solution</name>
                            <alias>dump-solution</alias>
                            <default>false</default>
                            <short_desc>Dump final solution for comparison with other solvers</short_desc>
                            <long_desc>
                                When this option is set to true, a representation of the resulting points-to
                                sets is dumped. The format is similar to that of the Dump PAG
                                option, and is therefore suitable for comparison with the results of other
                                solvers.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Topological Sort</name>
                            <alias>topo-sort</alias>
                            <default>false</default>
                            <short_desc>Sort variable nodes in dump</short_desc>
                            <long_desc>
                                When this option is set to true, the representation dumped by the
                                Dump PAG option
                                is dumped with the variable (green) nodes in (pseudo-)topological order.

                                This option has no effect unless Dump PAG is true.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Dump Types</name>
                            <alias>dump-types</alias>
                            <default>true</default>
                            <short_desc>Include declared types in dump</short_desc>
                            <long_desc>
                                When this option is set to true, the representation dumped by the
                                Dump PAG option
                                includes type information for all nodes.

                                This option has no effect unless Dump PAG is true.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Class Method Var</name>
                            <alias>class-method-var</alias>
                            <default>true</default>
                            <short_desc>In dump, label variables by class and method</short_desc>
                            <long_desc>
                                When this option is set to true, the representation dumped by the
                                Dump PAG option
                                represents nodes by numbering each class, method, and variable within
                                the method separately, rather than assigning a single integer to each
                                node.

                                This option has no effect unless Dump PAG is true. Setting Class
                                Method Var to true has the effect of setting Topological Sort to
                                false.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Dump Answer</name>
                            <alias>dump-answer</alias>
                            <default>false</default>
                            <short_desc>Dump computed reaching types for comparison with other solvers</short_desc>
                            <long_desc>
                                When this option is set to true, the computed reaching types for each variable are
                                dumped to a file, so that they can be compared with the results of
                                other analyses (such as the old VTA).
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Add Tags</name>
                            <alias>add-tags</alias>
                            <default>false</default>
                            <short_desc>Output points-to results in tags for viewing with the Jimple</short_desc>
                            <long_desc>
                                When this option is set to true, the results of the analysis are encoded within
                                tags and printed with the resulting Jimple code.

                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Calculate Set Mass</name>
                            <alias>set-mass</alias>
                            <default>false</default>
                            <short_desc>Calculate statistics about points-to set sizes</short_desc>
                            <long_desc>
                                When this option is set to true, Spark computes and prints various
                                cryptic statistics about the size of the points-to sets computed.
                            </long_desc>
                        </boolopt>
                    </section>
                    <section>
                        <name>Context-sensitive refinement</name>
                        <boolopt>
                            <name>Demand-driven refinement-based context-sensitive points-to analysis</name>
                            <alias>cs-demand</alias>
                            <default>false</default>
                            <short_desc>After running Spark, refine points-to sets on demand with context information
                            </short_desc>
                            <long_desc>
                                When this option is set to true, Manu Sridharan's demand-driven,
                                refinement-based points-to analysis (PLDI 06) is applied after Spark
                                was run.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Create lazy points-to sets</name>
                            <alias>lazy-pts</alias>
                            <default>true</default>
                            <short_desc>Create lazy points-to sets that create context information only when needed.
                            </short_desc>
                            <long_desc>
                                When this option is disabled, context information is computed for every query to the
                                reachingObjects method.
                                When it is enabled, a call to reachingObjects returns a lazy wrapper object that
                                contains a context-insensitive
                                points-to set. This set is then automatically refined with context information when
                                necessary, i.e.
                                when we try to determine the intersection with another points-to set and this
                                intersection seems to be
                                non-empty.
                            </long_desc>
                        </boolopt>
                        <intopt>
                            <name>Maximal traversal</name>
                            <alias>traversal</alias>
                            <default>75000</default>
                            <short_desc>Make the analysis traverse at most this number of nodes per query.</short_desc>
                            <long_desc>
                                Make the analysis traverse at most this number of nodes per query.
                                This quota is evenly shared between multiple passes (see next option).
                            </long_desc>
                        </intopt>
                        <intopt>
                            <name>Maximal number of passes</name>
                            <alias>passes</alias>
                            <default>10</default>
                            <short_desc>Perform at most this number of refinement iterations.</short_desc>
                            <long_desc>
                                Perform at most this number of refinement iterations.
                                Each iteration traverses at most ( traverse / passes ) nodes.
                            </long_desc>
                        </intopt>
                    </section>
                    <section>
                        <name>Geometric context-sensitive analysis from ISSTA 2011</name>
                        <boolopt>
                            <name>Geometric, context-sensitive points-to analysis</name>
                            <alias>geom-pta</alias>
                            <default>false</default>
                            <short_desc>This switch enables/disables the geometric analysis.</short_desc>
                            <long_desc>
                                This switch enables/disables the geometric analysis.
                            </long_desc>
                        </boolopt>
                        <multiopt>
                            <name>Encoding methodology used</name>
                            <alias>geom-encoding</alias>
                            <default>Geom</default>
                            <short_desc>Encoding methodology</short_desc>
                            <long_desc>
                                This switch specifies the encoding methodology used in the analysis.
                                All possible options are: Geom, HeapIns, PtIns. The efficiency order
                                is (from slow to fast) Geom - HeapIns - PtIns, but the precision order is
                                the reverse.
                            </long_desc>
                            <value>
                                <name>Geometric</name>
                                <alias>Geom</alias>
                                <short_desc>Geometric Encoding</short_desc>
                                <long_desc>
                                    Geometric Encoding.
                                </long_desc>
                                <default/>
                            </value>
                            <value>
                                <name>Heap Insensitive</name>
                                <alias>HeapIns</alias>
                                <short_desc>Heap Insensitive Encoding</short_desc>
                                <long_desc>
                                    Heap Insensitive Encoding. Omit the heap context range term in the encoded
                                    representation, and in turn, we assume all the contexts for this heap object are
                                    used.
                                </long_desc>
                            </value>
                            <value>
                                <name>Pointer Insensitive</name>
                                <alias>PtIns</alias>
                                <short_desc>PtIns</short_desc>
                                <long_desc>
                                    Pointer Insensitive Encoding. Similar to HeapIns, but we omit the pointer context
                                    range term.
                                </long_desc>
                            </value>
                        </multiopt>

                        <multiopt>
                            <name>Worklist type</name>
                            <alias>geom-worklist</alias>
                            <default>PQ</default>
                            <short_desc>Worklist type</short_desc>
                            <long_desc>
                                Specifies the worklist used for selecting the next propagation pointer. All possible
                                options are: PQ, FIFO. They stand for the priority queue (sorted by the last fire time
                                and topology order) and FIFO queue.
                            </long_desc>
                            <value>
                                <name>Priority Queue</name>
                                <alias>PQ</alias>
                                <short_desc>Priority Queue</short_desc>
                                <long_desc>
                                    Priority Queue (sorted by the last fire time and topology order)
                                </long_desc>
                                <default/>
                            </value>
                            <value>
                                <name>FIFO Queue</name>
                                <alias>FIFO</alias>
                                <short_desc>FIFO Queue</short_desc>
                                <long_desc>
                                    FIFO Queue
                                </long_desc>
                            </value>
                        </multiopt>

                        <stropt>
                            <name>Verbose dump file</name>
                            <alias>geom-dump-verbose</alias>
                            <default></default>
                            <set_arg_label>name</set_arg_label>
                            <short_desc>Filename for detailed execution log</short_desc>
                            <long_desc>
                                If you want to save the geomPTA analysis information for future analysis, please provide
                                a file name.
                            </long_desc>
                        </stropt>

                        <stropt>
                            <name>Verification file</name>
                            <alias>geom-verify-name</alias>
                            <default></default>
                            <set_arg_label>path</set_arg_label>
                            <short_desc>Filename for verification file</short_desc>
                            <long_desc>
                                If you want to compare the precision of the points-to results with other solvers (e.g.
                                Paddle), you can use the 'verify-file' to specify the list of methods (soot method
                                signature format) that are reachable by that solver. During the internal evaluations
                                (see the option geom-eval), we only consider the methods that are common to both
                                solvers.
                            </long_desc>
                        </stropt>

                        <intopt>
                            <name>Precision evaluation methodologies</name>
                            <alias>geom-eval</alias>
                            <default>0</default>
                            <short_desc>Precision evaluation methodologies</short_desc>
                            <long_desc>
                                We internally provide some precision evaluation methodologies and classify the
                                evaluation strength into three levels. If level is 0, we do nothing. If level is 1, we
                                report the statistical information about the points-to result. If level is 2, we perform
                                the virtual callsite resolution, static cast safety and all-pairs alias evaluations.
                            </long_desc>
                        </intopt>

                        <boolopt>
                            <name>Transform to context-insensitive result</name>
                            <alias>geom-trans</alias>
                            <default>false</default>
                            <short_desc>Transform to context-insensitive result</short_desc>
                            <long_desc>
                                If you stick to working with SPARK, you can use this option to transform the context
                                sensitive result to insensitive result. After the transformation, the context sensitive
                                points-to quries cannot be answered.
                            </long_desc>
                        </boolopt>

                        <intopt>
                            <name>Fractional parameter</name>
                            <alias>geom-frac-base</alias>
                            <default>40</default>
                            <short_desc>Fractional parameter for precision/performance trade-off</short_desc>
                            <long_desc>
                                This option specifies the fractional parameter, which manually balances the precision
                                and the performance. Smaller value means better performance and worse precision.
                            </long_desc>
                        </intopt>

                        <boolopt>
                            <name>Blocking strategy for recursive calls</name>
                            <alias>geom-blocking</alias>
                            <default>true</default>
                            <short_desc>Enable blocking strategy for recursive calls</short_desc>
                            <long_desc>
                                Blocking strategy is a 1CFA model for recursive calls. This model significantly improves
                                the precision.
                            </long_desc>
                        </boolopt>

                        <intopt>
                            <name>Iterations</name>
                            <alias>geom-runs</alias>
                            <default>1</default>
                            <short_desc>Iterations of analysis</short_desc>
                            <long_desc>
                                We can run multiple times of the geometric analysis to continuously improve the analysis
                                precision.
                            </long_desc>
                        </intopt>

                        <boolopt>
                            <name>Pointers processed by geomPTA</name>
                            <alias>geom-app-only</alias>
                            <default>true</default>
                            <short_desc>Processing pointers that impact pointers in application code only</short_desc>
                            <long_desc>
                                When this option is true, geomPTA only processes the pointers in library functions (
                                java.*, sun.*, and etc.) that potentially impact the points-to information of pointers
                                in application code, the pointers in application code, and the base pointers at virtual
                                callsites.
                            </long_desc>
                        </boolopt>

                        -->
                    </section>
                </sub_phase>
                <sub_phase>
                    <name>Paddle</name>
                    <class>PaddleOptions</class>
                    <alias>cg.paddle</alias>
                    <short_desc>Paddle points-to analysis framework</short_desc>
                    <long_desc>Paddle is a BDD-based interprocedural analysis framework. It includes points-to analysis,
                        call graph construction, and various client analyses.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <section>
                        <name>Paddle General Options</name>
                        <boolopt>
                            <name>Verbose</name>
                            <alias>verbose</alias>
                            <default>false</default>
                            <short_desc>Print detailed information about the execution of Paddle</short_desc>
                            <long_desc>
                                When this option is set to true, Paddle prints detailed information about its execution.
                            </long_desc>
                        </boolopt>
                        <multiopt>
                            <name>Configuration</name>
                            <alias>conf</alias>
                            <value>
                                <name>On-the fly call graph</name>
                                <alias>ofcg</alias>
                                <default/>
                                <short_desc>On-the fly call graph</short_desc>
                                <long_desc>
                                    Performs points-to analysis and builds call graph together, on-the-fly.
                                </long_desc>
                            </value>
                            <value>
                                <name>CHA only</name>
                                <alias>cha</alias>
                                <short_desc>CHA only</short_desc>
                                <long_desc>
                                    Builds only a call graph using Class Hieararchy Analysis, and performs no
                                    points-to analysis.
                                </long_desc>
                            </value>
                            <value>
                                <name>CHA ahead-of-time call graph</name>
                                <alias>cha-aot</alias>
                                <short_desc>CHA ahead-of-time callgraph</short_desc>
                                <long_desc>
                                    First builds a call graph using CHA, then uses the call graph in a fixed-call-graph
                                    points-to analysis.
                                </long_desc>
                            </value>
                            <value>
                                <name>OFCG-AOT</name>
                                <alias>ofcg-aot</alias>
                                <short_desc>OFCG-AOT callgraph</short_desc>
                                <long_desc>
                                    First builds a call graph on-the-fly during a points-to analysis, then
                                    uses the resulting call graph to perform a second points-to analysis
                                    with a fixed call graph.
                                </long_desc>
                            </value>
                            <value>
                                <name>CHA-Context-AOT call graph</name>
                                <alias>cha-context-aot</alias>
                                <short_desc>CHA-Context-AOT callgraph</short_desc>
                                <long_desc>
                                    First builds a call graph using CHA, then makes it context-sensitive using
                                    the technique described by Calman and Zhu in PLDI 04,
                                    then uses the call graph in a fixed-call-graph points-to analysis.
                                </long_desc>
                            </value>
                            <value>
                                <name>OFCG-Context-AOT</name>
                                <alias>ofcg-context-aot</alias>
                                <short_desc>OFCG-Context-AOT callgraph</short_desc>
                                <long_desc>
                                    First builds a call graph on-the-fly during a points-to analysis, then
                                    makes it context-sensitive using the technique described by Calman and
                                    Zhu in PLDI 04, then uses the resulting call graph to perform a second
                                    points-to analysis with a fixed call graph.
                                </long_desc>
                            </value>
                            <value>
                                <name>CHA-Context call graph</name>
                                <alias>cha-context</alias>
                                <short_desc>CHA-Context callgraph</short_desc>
                                <long_desc>
                                    First builds a call graph using CHA, then makes it context-sensitive using
                                    the technique described by Calman and Zhu in PLDI 04. Does not produce
                                    points-to information.
                                </long_desc>
                            </value>
                            <value>
                                <name>OFCG-Context</name>
                                <alias>ofcg-context</alias>
                                <short_desc>OFCG-Context callgraph</short_desc>
                                <long_desc>
                                    First builds a call graph on-the-fly during a points-to analysis, then
                                    makes it context-sensitive using the technique described by Calman and
                                    Zhu in PLDI 04. Does not perform a subsequent points-to analysis.
                                </long_desc>
                            </value>
                            <short_desc>Select Paddle configuration</short_desc>
                            <long_desc>
                                Selects the configuration of points-to analysis and call graph construction
                                to be used in Paddle.
                            </long_desc>
                        </multiopt>
                        <boolopt>
                            <name>Use BDDs</name>
                            <alias>bdd</alias>
                            <default>false</default>
                            <short_desc>Use BDD version of Paddle</short_desc>
                            <long_desc>
                                Causes Paddle to use BDD versions of its components
                            </long_desc>
                        </boolopt>
                        <intopt>
                            <name>Variable ordering</name>
                            <alias>order</alias>
                            <default>32</default>
                            <short_desc/>
                            <long_desc>
                                Selects one of the BDD variable orderings hard-coded in Paddle.
                            </long_desc>
                        </intopt>
                        <boolopt>
                            <name>Dynamic reordering</name>
                            <alias>dynamic-order</alias>
                            <short_desc/>
                            <long_desc>
                                Allows the BDD package to perform dynamic variable ordering.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Profile</name>
                            <alias>profile</alias>
                            <default>false</default>
                            <short_desc>Profile BDDs using JeddProfiler</short_desc>
                            <long_desc>
                                Turns on JeddProfiler for profiling BDD operations.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Verbose GC</name>
                            <alias>verbosegc</alias>
                            <default>false</default>
                            <short_desc>Print memory usage at each BDD garbage collection.</short_desc>
                            <long_desc>
                                Print memory usage at each BDD garbage collection.
                            </long_desc>
                        </boolopt>
                        <multiopt>
                            <name>Worklist Implementation</name>
                            <alias>q</alias>
                            <value>
                                <name>Select Automatically</name>
                                <alias>auto</alias>
                                <default/>
                                <short_desc>Select queue implementation based on bdd option</short_desc>
                                <long_desc>
                                    When the bdd option is true, the BDD-based worklist implementation will be used.
                                    When the bdd option is false, the Traditional worklist implementation will be used.
                                </long_desc>
                            </value>
                            <value>
                                <name>Traditional</name>
                                <alias>trad</alias>
                                <short_desc>Normal worklist queue implementation</short_desc>
                                <long_desc>
                                    Normal worklist queue implementation
                                </long_desc>
                            </value>
                            <value>
                                <name>BDD</name>
                                <alias>bdd</alias>
                                <short_desc>BDD-based queue implementation</short_desc>
                                <long_desc>
                                    BDD-based queue implementation
                                </long_desc>
                            </value>
                            <value>
                                <name>Debug</name>
                                <alias>debug</alias>
                                <short_desc>Debugging queue implementation</short_desc>
                                <long_desc>
                                    An implementation of worklists that includes both traditional and BDD-based
                                    implementations, and signals an error whenever their contents differ.
                                </long_desc>
                            </value>
                            <value>
                                <name>Trace</name>
                                <alias>trace</alias>
                                <short_desc>Tracing queue implementation</short_desc>
                                <long_desc>
                                    A worklist implementation that prints out all tuples added to every worklist.
                                </long_desc>
                            </value>
                            <value>
                                <name>Number Trace</name>
                                <alias>numtrace</alias>
                                <short_desc>Number-tracing queue implementation</short_desc>
                                <long_desc>
                                    A worklist implementation that prints out the number of tuples added to
                                    each worklist after each operation.
                                </long_desc>
                            </value>
                            <short_desc>Select queue implementation</short_desc>
                            <long_desc>
                                Select the implementation of worklists to be used in Paddle.
                            </long_desc>
                        </multiopt>
                        <multiopt>
                            <name>Backend</name>
                            <alias>backend</alias>
                            <value>
                                <name>Select Automatically</name>
                                <alias>auto</alias>
                                <default/>
                                <short_desc>Select backend based on bdd option</short_desc>
                                <long_desc>
                                    When the bdd option is true, the BuDDy backend will be used.
                                    When the bdd option is false, the backend will be set to none, to avoid
                                    loading any BDD backend.
                                </long_desc>
                            </value>
                            <value>
                                <name>BuDDy</name>
                                <alias>buddy</alias>
                                <short_desc>BuDDy backend</short_desc>
                                <long_desc>
                                    Use BuDDy implementation of BDDs.
                                </long_desc>
                            </value>
                            <value>
                                <name>CUDD</name>
                                <alias>cudd</alias>
                                <short_desc>CUDD backend</short_desc>
                                <long_desc>
                                    Use CUDD implementation of BDDs.
                                </long_desc>

                            </value>
                            <value>
                                <name>SableJBDD</name>
                                <alias>sable</alias>
                                <short_desc>SableJBDD backend</short_desc>
                                <long_desc>Use SableJBDD implementation of BDDs.</long_desc>
                            </value>
                            <value>
                                <name>JavaBDD</name>
                                <alias>javabdd</alias>
                                <short_desc>JavaBDD backend</short_desc>
                                <long_desc>
                                    Use JavaBDD implementation of BDDs.
                                </long_desc>
                            </value>
                            <value>
                                <name>None</name>
                                <alias>none</alias>
                                <short_desc>No BDDs</short_desc>
                                <long_desc>
                                    Don't use any BDD backend. Any attempted use of BDDs will cause Paddle to crash.
                                </long_desc>
                            </value>
                            <short_desc>Select BDD backend</short_desc>
                            <long_desc>
                                This option tells Paddle which implementation of BDDs to use.
                            </long_desc>
                        </multiopt>
                        <intopt>
                            <name>BDD Nodes</name>
                            <alias>bdd-nodes</alias>
                            <default>0</default>
                            <short_desc>Number of BDD nodes to allocate (0=unlimited)</short_desc>
                            <long_desc>
                                This option specifies the number of BDD nodes to be used by the BDD backend.
                                A value of 0 causes the backend to start with one million nodes, and allocate
                                more as required. A value other than zero causes the backend to start with
                                the specified size, and prevents it from ever allocating any more nodes.
                            </long_desc>
                        </intopt>
                        <boolopt>
                            <name>Ignore Types Entirely</name>
                            <alias>ignore-types</alias>
                            <default>false</default>
                            <short_desc>Make Paddle completely ignore declared types of variables</short_desc>
                            <long_desc>
                                When this option is set to true, all parts of Paddle completely ignore
                                declared types of variables and casts.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Pre Jimplify</name>
                            <alias>pre-jimplify</alias>
                            <default>false</default>
                            <short_desc>Jimplify all methods before starting Paddle</short_desc>
                            <long_desc>
                                When this option is set to true, Paddle converts all available methods to Jimple
                                before starting the points-to analysis. This allows the Jimplification
                                time to be separated from the points-to time. However, it increases the
                                total time and memory requirement, because all methods are Jimplified,
                                rather than only those deemed reachable by the points-to analysis.
                            </long_desc>
                        </boolopt>
                    </section>
                    <section>
                        <name>Paddle Context Sensitivity Options</name>
                        <multiopt>
                            <name>Context abstraction</name>
                            <alias>context</alias>
                            <value>
                                <name>Context-insensitive</name>
                                <alias>insens</alias>
                                <default/>
                                <short_desc>Builds a context-insensitive call graph</short_desc>
                                <long_desc>
                                    Builds a context-insensitive call graph.
                                </long_desc>
                            </value>
                            <value>
                                <name>1-CFA</name>
                                <alias>1cfa</alias>
                                <short_desc>Builds a 1-CFA call graph</short_desc>
                                <long_desc>
                                    Builds a 1-CFA call graph.
                                </long_desc>

                            </value>
                            <value>
                                <name>k-CFA</name>
                                <alias>kcfa</alias>
                                <short_desc>Builds a k-CFA call graph</short_desc>
                                <long_desc>
                                    Builds a k-CFA call graph.
                                </long_desc>

                            </value>
                            <value>
                                <name>Object Sensitive</name>
                                <alias>objsens</alias>
                                <short_desc>Builds an object-sensitive call graph</short_desc>
                                <long_desc>
                                    Builds an object-sensitive call graph.
                                </long_desc>

                            </value>
                            <value>
                                <name>k-Object Sensitive</name>
                                <alias>kobjsens</alias>
                                <short_desc>Builds a k-object-sensitive call graph</short_desc>
                                <long_desc>
                                    Builds a context-sensitive call graph where the context is a string of up to
                                    k receiver objects.
                                </long_desc>

                            </value>
                            <value>
                                <name>Unique k-Object Sensitive</name>
                                <alias>uniqkobjsens</alias>
                                <short_desc>Builds a unique-k-object-sensitive call graph</short_desc>
                                <long_desc>
                                    Builds a context-sensitive call graph where the context is a string of up to
                                    k unique receiver objects. If the receiver of a call already appears in the
                                    context string, the context string is just reused as is.
                                </long_desc>

                            </value>
                            <value>
                                <name>Thread k-Object Sensitive</name>
                                <alias>threadkobjsens</alias>
                                <short_desc>Experimental option for thread-entry-point sensitivity</short_desc>
                                <long_desc>
                                    Experimental option for thread-entry-point sensitivity.
                                </long_desc>

                            </value>
                            <short_desc>Select context-sensitivity level</short_desc>
                            <long_desc>
                                This option tells Paddle which level of context-sensitivity to use in constructing the
                                call graph.
                            </long_desc>
                        </multiopt>
                        <intopt>
                            <name>Context length (k)</name>
                            <alias>k</alias>
                            <default>2</default>
                            <short_desc/>
                            <long_desc>
                                The maximum length of call string or receiver object string used as context.
                            </long_desc>
                        </intopt>
                        <boolopt>
                            <name>Context-sensitive Heap Locations</name>
                            <alias>context-heap</alias>
                            <default>false</default>
                            <short_desc>Treat allocation sites context-sensitively</short_desc>
                            <long_desc>
                                When this option is set to true, the context-sensitivity level that is set
                                for the context-sensitive call graph and for pointer variables is also used
                                to model heap locations context-sensitively. When this option is false,
                                heap locations are modelled context-insensitively regardless of the
                                context-sensitivity level.
                            </long_desc>
                        </boolopt>
                    </section>
                    <section>
                        <name>Paddle Pointer Assignment Graph Building Options</name>
                        <boolopt>
                            <name>RTA</name>
                            <alias>rta</alias>
                            <default>false</default>
                            <short_desc>Emulate Rapid Type Analysis</short_desc>
                            <long_desc>
                                Setting RTA to true sets types-for-sites to true, and causes Paddle to use
                                a single points-to set for all variables, giving <a
                                    href="http://doi.acm.org/10.1145/236337.236371">Rapid Type
                                Analysis</a>.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Field Based</name>
                            <alias>field-based</alias>
                            <default>false</default>
                            <short_desc>Use a field-based rather than field-sensitive representation</short_desc>
                            <long_desc>
                                When this option is set to true, fields are represented by variable
                                (Green) nodes, and the object that the field belongs to is ignored
                                (all objects are lumped together), giving a field-based analysis. Otherwise, fields are
                                represented by
                                field reference (Red) nodes, and the objects that they belong to are
                                distinguished, giving a field-sensitive analysis.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Types For Sites</name>
                            <alias>types-for-sites</alias>
                            <default>false</default>
                            <short_desc>Represent objects by their actual type rather than allocation site</short_desc>
                            <long_desc>
                                When this option is set to true, types rather than allocation sites are
                                used as the elements of the points-to sets.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Merge String Buffer</name>
                            <alias>merge-stringbuffer</alias>
                            <default>true</default>
                            <short_desc>Represent all StringBuffers as one object</short_desc>
                            <long_desc>
                                When this option is set to true, all allocation sites creating
                                <tt>java.lang.StringBuffer</tt>
                                objects are grouped together as a single
                                allocation site. Allocation sites creating a
                                <tt>java.lang.StringBuilder</tt>
                                object are also grouped together as a single allocation site.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Propagate All String Constants</name>
                            <alias>string-constants</alias>
                            <default>false</default>
                            <short_desc>Propagate all string constants, not just class names</short_desc>
                            <long_desc>
                                When this option is set to false, Paddle only distinguishes string constants that
                                may be the name of a class loaded dynamically using reflection, and all other
                                string constants are lumped together into a single string constant node.
                                Setting this option to true causes all string constants to be propagated
                                individually.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Simulate Natives</name>
                            <alias>simulate-natives</alias>
                            <default>true</default>
                            <short_desc>Simulate effects of native methods in standard class library</short_desc>
                            <long_desc>
                                When this option is set to true, the effects of native methods in the standard Java
                                class library are simulated.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Global Nodes in Simulated Natives</name>
                            <alias>global-nodes-in-natives</alias>
                            <default>false</default>
                            <short_desc>Use global node to model variables in simulations of native methods</short_desc>
                            <long_desc>
                                The simulations of native methods such as System.arraycopy() use
                                temporary local variable nodes. Setting this switch to true causes them
                                to use global variable nodes instead, reducing precision. The switch
                                exists only to make it possible to measure this effect on precision;
                                there is no other practical reason to set it to true.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Simple Edges Bidirectional</name>
                            <alias>simple-edges-bidirectional</alias>
                            <default>false</default>
                            <short_desc>Equality-based analysis between variable nodes</short_desc>
                            <long_desc>
                                When this option is set to true, all edges connecting variable (Green)
                                nodes are made bidirectional, as in <a href="http://doi.acm.org/10.1145/237721.237727">
                                Steensgaard&apos;s analysis</a>.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>this Pointer Assignment Edge</name>
                            <alias>this-edges</alias>
                            <default>false</default>
                            <short_desc>Use pointer assignment edges to model this parameters</short_desc>
                            <long_desc>
                                When constructing a call graph on-the-fly during points-to analysis, Paddle
                                normally propagates only those receivers that cause a method to be invoked
                                to the this pointer of the method. When this option is set to true, however,
                                Paddle instead models flow of receivers as an assignnment edge from the
                                receiver at the call site to the this pointer of the method, reducing
                                precision.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Precise newInstance</name>
                            <alias>precise-newinstance</alias>
                            <default>true</default>
                            <short_desc>Make newInstance only allocate objects of dynamic classes</short_desc>
                            <long_desc>
                                Normally, newInstance() calls are treated as if they may return an object
                                of any type. Setting this option to true causes them to be treated as if
                                they return only objects of the type of some dynamic class.
                            </long_desc>
                        </boolopt>
                    </section>
                    <section>
                        <name>Paddle Points-To Set Flowing Options</name>
                        <multiopt>
                            <name>Propagator</name>
                            <alias>propagator</alias>
                            <value>
                                <name>Select Automatically</name>
                                <alias>auto</alias>
                                <default/>
                                <short_desc>Select propagation algorithm based on bdd option</short_desc>
                                <long_desc>
                                    When the bdd option is true, the Incremental BDD propagation algorithm will be used.
                                    When the bdd option is false, the Worklist propagation algorithm will be used.
                                </long_desc>
                            </value>
                            <value>
                                <name>Iter</name>
                                <alias>iter</alias>
                                <short_desc>Simple iterative algorithm</short_desc>
                                <long_desc>
                                    Iter is a simple, iterative algorithm, which propagates everything until the
                                    graph does not change.
                                </long_desc>
                            </value>
                            <value>
                                <name>Worklist</name>
                                <alias>worklist</alias>
                                <short_desc>Fast, worklist-based algorithm</short_desc>
                                <long_desc>
                                    Worklist is a worklist-based algorithm that tries
                                    to do as little work as possible. This is currently the fastest algorithm.
                                </long_desc>

                            </value>
                            <value>
                                <name>Alias</name>
                                <alias>alias</alias>
                                <short_desc>Alias-edge based algorithm</short_desc>
                                <long_desc>
                                    Alias is an alias-edge based algorithm. This algorithm tends to take
                                    the least memory for very large problems, because it does not represent
                                    explicitly points-to sets of fields of heap objects.
                                </long_desc>

                            </value>
                            <value>
                                <name>BDD</name>
                                <alias>bdd</alias>
                                <short_desc>BDD-based propagator</short_desc>
                                <long_desc>
                                    BDD is a propagator that stores points-to sets in binary decision diagrams.
                                </long_desc>
                            </value>
                            <value>
                                <name>Incrementalized BDD</name>
                                <alias>incbdd</alias>
                                <short_desc>Incrementalized BDD-based propagator</short_desc>
                                <long_desc>
                                    A propagator that stores points-to sets in binary decision diagrams, and propagates
                                    them incrementally.
                                </long_desc>
                            </value>
                            <short_desc>Select propagation algorithm</short_desc>
                            <long_desc>
                                This option tells Paddle which propagation algorithm to use.
                            </long_desc>
                        </multiopt>
                        <multiopt>
                            <name>Set Implementation</name>
                            <alias>set-impl</alias>
                            <value>
                                <name>Hash set</name>
                                <alias>hash</alias>
                                <short_desc>Use Java HashSet</short_desc>

                                <long_desc>
                                    Hash is an implementation based on Java&apos;s built-in hash-set.
                                </long_desc>
                            </value>
                            <value>
                                <name>Bit-vector</name>
                                <alias>bit</alias>
                                <short_desc>Bit vector</short_desc>
                                <long_desc>
                                    Bit is an implementation using a bit vector.
                                </long_desc>
                            </value>
                            <value>
                                <name>Hybrid</name>
                                <alias>hybrid</alias>
                                <short_desc>Hybrid representation using bit vector for large sets</short_desc>
                                <long_desc>
                                    Hybrid is an implementation that keeps an explicit list of up to
                                    16 elements, and switches to a bit-vector when the set gets
                                    larger than this.
                                </long_desc>
                            </value>
                            <value>
                                <name>Sorted array</name>
                                <alias>array</alias>
                                <short_desc>Sorted array representation</short_desc>
                                <long_desc>
                                    Array is an implementation that keeps the elements of the
                                    points-to set in a sorted array. Set membership is tested using
                                    binary search, and set union and intersection are computed using
                                    an algorithm based on the merge step from merge sort.
                                </long_desc>
                            </value>
                            <value>
                                <name>Heintze</name>
                                <alias>heintze</alias>
                                <short_desc>Heintze's shared bit-vector and overflow list representation</short_desc>
                                <long_desc>Heintze's representation has elements represented by a bit-vector + a small
                                    'overflow' list of some maximum number of elements. The bit-vectors can be shared
                                    by multiple points-to sets, while the overflow lists are not.
                                </long_desc>
                            </value>
                            <value>
                                <name>Double</name>
                                <alias>double</alias>
                                <default/>
                                <short_desc>Double set representation for incremental propagation</short_desc>
                                <long_desc>
                                    Double is an implementation that itself uses a pair of sets for
                                    each points-to set. The first set in the pair stores new pointed-to
                                    objects that have not yet been propagated, while the second set stores
                                    old pointed-to objects that have been propagated and need not be
                                    reconsidered. This allows the propagation algorithms to be incremental,
                                    often speeding them up significantly.
                                </long_desc>
                            </value>
                            <short_desc>Select points-to set implementation</short_desc>
                            <long_desc>
                                Select an implementation of points-to sets for Paddle to use.
                            </long_desc>
                        </multiopt>
                        <multiopt>
                            <name>Double Set Old</name>
                            <alias>double-set-old</alias>
                            <value>
                                <name>Hash set</name>
                                <alias>hash</alias>
                                <short_desc>Use Java HashSet</short_desc>

                                <long_desc>
                                    Hash is an implementation based on Java&apos;s built-in hash-set.
                                </long_desc>
                            </value>
                            <value>
                                <name>Bit-vector</name>
                                <alias>bit</alias>
                                <short_desc>Bit vector</short_desc>
                                <long_desc>
                                    Bit is an implementation using a bit vector.
                                </long_desc>
                            </value>
                            <value>
                                <name>Hybrid</name>
                                <alias>hybrid</alias>
                                <default/>
                                <short_desc>Hybrid representation using bit vector for large sets</short_desc>
                                <long_desc>
                                    Hybrid is an implementation that keeps an explicit list of up to
                                    16 elements, and switches to a bit-vector when the set gets
                                    larger than this.
                                </long_desc>
                            </value>
                            <value>
                                <name>Sorted array</name>
                                <alias>array</alias>
                                <short_desc>Sorted array representation</short_desc>
                                <long_desc>
                                    Array is an implementation that keeps the elements of the
                                    points-to set in a sorted array. Set membership is tested using
                                    binary search, and set union and intersection are computed using
                                    an algorithm based on the merge step from merge sort.
                                </long_desc>
                            </value>
                            <value>
                                <name>Heintze</name>
                                <alias>heintze</alias>
                                <short_desc>Heintze's shared bit-vector and overflow list representation</short_desc>
                                <long_desc>Heintze's representation has elements represented by a bit-vector + a small
                                    'overflow' list of some maximum number of elements. The bit-vectors can be shared
                                    by multiple points-to sets, while the overflow lists are not.
                                </long_desc>
                            </value>
                            <short_desc>Select implementation of points-to set for old part of double set</short_desc>
                            <long_desc>
                                Select an implementation for sets of old objects in the double
                                points-to set implementation.

                                This option has no effect unless Set Implementation is set to double.
                            </long_desc>
                        </multiopt>
                        <multiopt>
                            <name>Double Set New</name>
                            <alias>double-set-new</alias>
                            <value>
                                <name>Hash set</name>
                                <alias>hash</alias>
                                <short_desc>Use Java HashSet</short_desc>

                                <long_desc>
                                    Hash is an implementation based on Java&apos;s built-in hash-set.
                                </long_desc>
                            </value>
                            <value>
                                <name>Bit-vector</name>
                                <alias>bit</alias>
                                <short_desc>Bit vector</short_desc>
                                <long_desc>
                                    Bit is an implementation using a bit vector.
                                </long_desc>
                            </value>
                            <value>
                                <name>Hybrid</name>
                                <alias>hybrid</alias>
                                <default/>
                                <short_desc>Hybrid representation using bit vector for large sets</short_desc>
                                <long_desc>
                                    Hybrid is an implementation that keeps an explicit list of up to
                                    16 elements, and switches to a bit-vector when the set gets
                                    larger than this.
                                </long_desc>
                            </value>
                            <value>
                                <name>Sorted array</name>
                                <alias>array</alias>
                                <short_desc>Sorted array representation</short_desc>
                                <long_desc>
                                    Array is an implementation that keeps the elements of the
                                    points-to set in a sorted array. Set membership is tested using
                                    binary search, and set union and intersection are computed using
                                    an algorithm based on the merge step from merge sort.
                                </long_desc>
                            </value>
                            <value>
                                <name>Heintze</name>
                                <alias>heintze</alias>
                                <short_desc>Heintze's shared bit-vector and overflow list representation</short_desc>
                                <long_desc>Heintze's representation has elements represented by a bit-vector + a small
                                    'overflow' list of some maximum number of elements. The bit-vectors can be shared
                                    by multiple points-to sets, while the overflow lists are not.
                                </long_desc>
                            </value>
                            <short_desc>Select implementation of points-to set for new part of double set</short_desc>
                            <long_desc>
                                Select an implementation for sets of new objects in the double
                                points-to set implementation.

                                This option has no effect unless Set Implementation is set to double.
                            </long_desc>
                        </multiopt>
                    </section>
                    <section>
                        <name>Paddle Output Options</name>
                        <boolopt>
                            <name>Print Context Counts</name>
                            <alias>context-counts</alias>
                            <default>false</default>
                            <short_desc>Print number of contexts for each method</short_desc>
                            <long_desc>
                                Causes Paddle to print the number of contexts for each method and
                                call edge, and the number of equivalence classes of contexts for
                                each variable node.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Print Context Counts (Totals only)</name>
                            <alias>total-context-counts</alias>
                            <default>false</default>
                            <short_desc>Print total number of contexts</short_desc>
                            <long_desc>
                                Causes Paddle to print the number of contexts and number of context
                                equivalence classes.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Method Context Counts (Totals only)</name>
                            <alias>method-context-counts</alias>
                            <default>false</default>
                            <short_desc>Print number of contexts for each method</short_desc>
                            <long_desc>
                                Causes Paddle to print the number of contexts and number of context
                                equivalence classes split out by method. Requires total-context-counts to also be turned
                                on.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Calculate Set Mass</name>
                            <alias>set-mass</alias>
                            <default>false</default>
                            <short_desc>Calculate statistics about points-to set sizes</short_desc>
                            <long_desc>
                                When this option is set to true, Paddle computes and prints various
                                cryptic statistics about the size of the points-to sets computed.
                            </long_desc>
                        </boolopt>
                        <boolopt>
                            <name>Number nodes</name>
                            <alias>number-nodes</alias>
                            <default>true</default>
                            <short_desc>Print node numbers in dumps</short_desc>
                            <long_desc>
                                When printing debug information about nodes, this option causes the node number
                                of each node to be printed.
                            </long_desc>
                        </boolopt>
                    </section>
                </sub_phase>
            </radio_phase>

            <phase>
                <name>Whole Shimple Transformation Pack</name>
                <alias>wstp</alias>
                <short_desc>Whole-shimple transformation pack</short_desc>
                <long_desc>
                    <p>
                        Soot can perform whole-program analyses. In whole-shimple mode, Soot
                        applies the contents of the Whole-Shimple Transformation Pack to the
                        scene as a whole after constructing a call graph for the program.
                    </p>
                    <p>
                        In an unmodified copy of Soot the Whole-Shimple Transformation
                        Pack is empty.
                    </p>
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>true</default>
                </boolopt>
            </phase>
            <phase>
                <name>Whole Shimple Optimization Pack</name>
                <alias>wsop</alias>
                <short_desc>Whole-shimple optimization pack</short_desc>
                <long_desc>
                    <p>
                        If Soot is running in whole shimple mode and the Whole-Shimple
                        Optimization Pack is enabled, the pack's transformations are
                        applied to the scene as a whole after construction of the call
                        graph and application of any enabled Whole-Shimple
                        Transformations.
                    </p>
                    <p>
                        In an unmodified copy of Soot the Whole-Shimple Optimization
                        Pack is empty.
                    </p>
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>false</default>
                </boolopt>
            </phase>

            <phase>
                <name>Whole-Jimple Transformation Pack</name>
                <alias>wjtp</alias>
                <short_desc>Whole-jimple transformation pack</short_desc>
                <long_desc>
                    <p>
                        Soot can perform whole-program analyses. In whole-program mode,
                        Soot applies the contents of the Whole-Jimple Transformation Pack
                        to the scene as a whole after constructing a call graph for the
                        program.
                    </p>
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>true</default>
                    <short_desc/>
                    <long_desc/>
                </boolopt>
                <sub_phase>
                    <name>May Happen in Parallel Analyses</name>
                    <class>MhpTransformer</class>
                    <alias>wjtp.mhp</alias>
                    <short_desc>Determines what statements may be run concurrently</short_desc>
                    <long_desc>
                        May Happen in Parallel (MHP) Analyses determine what program statements may
                        be run by different threads concurrently. This phase does not perform any
                        transformation.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Lock Allocator</name>
                    <class>LockAllocator</class>
                    <alias>wjtp.tn</alias>
                    <short_desc>Finds critical sections, allocates locks</short_desc>
                    <long_desc>
                        The Lock Allocator finds critical sections (synchronized regions)
                        in Java programs and assigns locks for execution on both
                        optimistic and pessimistic JVMs. It can also be used to analyze the existing
                        locks.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <multiopt>
                        <name>Locking Scheme</name>
                        <alias>locking-scheme</alias>
                        <set_arg_label>granularity</set_arg_label>
                        <short_desc>Selects the granularity of the generated lock allocation</short_desc>
                        <long_desc>Selects the granularity of the generated lock allocation</long_desc>
                        <!--						<value>
							<name>Fine Grained</name>
							<alias>fine-grained</alias>
							<short_desc>Use multiple runtime objects for synchronization</short_desc>
							<long_desc>
Try to identify transactional regions that can employ fine-grained locking to
increase parallelism.  All side effects must be protected by a single object.
This locking scheme aims to achieve simple fine-grained locking.
</long_desc>
						</value> -->
                        <value>
                            <name>Medium Grained</name>
                            <alias>medium-grained</alias>
                            <short_desc>Use a runtime object for synchronization where possible</short_desc>
                            <long_desc>
                                Try to identify transactional regions that can employ a dynamic lock to
                                increase parallelism. All side effects must be protected by a single object.
                                This locking scheme aims to approximate typical Java Monitor usage.
                            </long_desc>
                            <default/>
                        </value>
                        <value>
                            <name>Coarse Grained</name>
                            <alias>coarse-grained</alias>
                            <short_desc>Use static objects for synchronization</short_desc>
                            <long_desc>
                                Insert static objects into the program for synchronization. One object will be
                                used for each group of conflicting synchronized regions. This locking scheme
                                achieves code-level locking.
                            </long_desc>
                        </value>
                        <value>
                            <name>Single Static Lock</name>
                            <alias>single-static</alias>
                            <short_desc>Use just one static synchronization object for all transactional regions
                            </short_desc>
                            <long_desc>
                                Insert one static object into the program for synchronization for all
                                transactional regions. This locking scheme is for research purposes.
                            </long_desc>
                        </value>
                        <value>
                            <name>Leave Original Locks</name>
                            <alias>leave-original</alias>
                            <short_desc>Analyse the existing lock structure without making changes</short_desc>
                            <long_desc>
                                Analyse the existing lock structure of the program, but do not change it. With
                                one of the print options, this can be useful for comparison between the original
                                program and one of the generated locking schemes.
                            </long_desc>
                        </value>
                    </multiopt>
                    <boolopt>
                        <name>Perform Deadlock Avoidance</name>
                        <alias>avoid-deadlock</alias>
                        <default>true</default>
                        <short_desc>Perform Deadlock Avoidance</short_desc>
                        <long_desc>
                            Perform Deadlock Avoidance by enforcing a lock ordering where necessary.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>Use Open Nesting</name>
                        <alias>open-nesting</alias>
                        <default>true</default>
                        <short_desc>Use an open nesting model</short_desc>
                        <long_desc>
                            Use an open nesting model, where inner transactions are allowed to commit
                            independently of any outer transaction.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>Perform May-Happen-in-Parallel Analysis</name>
                        <alias>do-mhp</alias>
                        <default>true</default>
                        <short_desc>Perform a May-Happen-in-Parallel analysis</short_desc>
                        <long_desc>
                            Perform a May-Happen-in-Parallel analysis to assist in allocating locks.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>Perform Local Objects Analysis</name>
                        <alias>do-tlo</alias>
                        <default>true</default>
                        <short_desc>Perform a Local-Objects analysis</short_desc>
                        <long_desc>
                            Perform a Local-Objects analysis to assist in allocating locks.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>Print Topological Graph</name>
                        <alias>print-graph</alias>
                        <default>false</default>
                        <short_desc>Print topological graph of transactions</short_desc>
                        <long_desc>
                            Print a topological graph of the program's transactions in the format used by the graphviz
                            package.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>Print Table</name>
                        <alias>print-table</alias>
                        <default>false</default>
                        <short_desc>Print table of transactions</short_desc>
                        <long_desc>
                            Print a table of information about the program's transactions.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>Print Debugging Info</name>
                        <alias>print-debug</alias>
                        <default>false</default>
                        <short_desc>Print debugging info</short_desc>
                        <long_desc>
                            Print debugging info, including every statement visited.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Rename duplicated classes</name>
                    <class>RenameDuplicatedClasses</class>
                    <alias>wjtp.rdc</alias>
                    <short_desc>Rename duplicated classes when the file system is not case sensitive</short_desc>
                    <long_desc>
                        Rename duplicated classes when the file system is not case sensitive.
                        If the file system is case sensitive, this phase does nothing.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <stropt>
                        <name>FixedClassNames</name>
                        <alias>fcn</alias>
                        <alias>fixed-class-names</alias>
                        <set_arg_label>nameList</set_arg_label>
                        <short_desc>Set
                            <use_arg_label/>
                            for the fixed class names.
                        </short_desc>
                        <long_desc>
                            Use this parameter to set some class names unchangable even they are duplicated.
                            The fixed class name list cannot contain duplicated class names.
                            Using '-' to split multiple class names (e.g., fcn:a.b.c-a.b.d).
                        </long_desc>
                    </stropt>
                </sub_phase>
            </phase>
            <phase>
                <name>Whole-Jimple Optimization Pack</name>
                <alias>wjop</alias>
                <short_desc>Whole-jimple optimization pack</short_desc>
                <long_desc>
                    <p>
                        If Soot is running in whole program mode and the Whole-Jimple
                        Optimization Pack is enabled, the pack's transformations are
                        applied to the scene as a whole after construction of the call
                        graph and application of any enabled Whole-Jimple
                        Transformations.
                    </p>
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>false</default>
                    <short_desc/>
                    <long_desc/>
                </boolopt>
                <sub_phase>
                    <name>Static Method Binder</name>
                    <class>SMBOptions</class>
                    <alias>wjop.smb</alias>
                    <short_desc>Static method binder: Devirtualizes monomorphic calls</short_desc>
                    <long_desc>
                        The Static Method Binder statically binds monomorphic call
                        sites. That is, it searches the call graph for virtual method
                        invocations that can be determined statically to call only a single
                        implementation of the called method. Then it replaces such virtual
                        invocations with invocations of a static copy of the single called
                        implementation.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Insert Null Checks</name>
                        <alias>insert-null-checks</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc>
                            Insert a check that, before invoking the static copy of the
                            target method, throws a <tt>NullPointerException</tt> if the
                            receiver object is null. This ensures that static method binding does
                            not eliminate exceptions which would have occurred in its absence.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>Insert Redundant Casts</name>
                        <alias>insert-redundant-casts</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc>
                            <p>
                                Insert extra casts for the Java bytecode verifier. If the target
                                method uses its <tt>this</tt> parameter, a reference to the
                                receiver object must be passed to the static copy of the target
                                method. The verifier may complain if the declared type of the
                                receiver parameter does not match the type implementing the
                                target method.
                            </p>
                            <p>
                                Say, for example, that <tt>Singer</tt> is an interface declaring
                                the <tt>sing()</tt> method and that the call graph shows all
                                receiver objects at a particular call site,
                                <tt>singer.sing()</tt>
                                (with <tt>singer</tt> declared as a
                                <tt>Singer</tt>) are in fact <tt>Bird</tt> objects (
                                <tt>Bird</tt>
                                being a class that implements <tt>Singer</tt>). The virtual call
                                <tt>singer.sing()</tt>
                                is effectively replaced with the static
                                call <tt>Bird.staticsing(singer)</tt>.
                                <tt>Bird.staticsing()</tt>
                                may perform operations on its parameter which are only allowed on
                                <tt>Bird</tt>s, rather than <tt>Singer</tt>s. The Insert
                                Redundant Casts option inserts a cast of <tt>singer</tt> to the
                                <tt>Bird</tt>
                                type, to prevent complaints from the verifier.
                            </p>
                        </long_desc>
                    </boolopt>
                    <multiopt>
                        <name>Allowed Modifier Changes</name>
                        <alias>allowed-modifier-changes</alias>
                        <value>
                            <name>Unsafe</name>
                            <alias>unsafe</alias>
                            <short_desc/>
                            <long_desc>
                                Modify the visibility on code so that all inlining is permitted.
                            </long_desc>
                            <default/>
                        </value>
                        <value>
                            <name>Safe</name>
                            <alias>safe</alias>
                            <short_desc/>
                            <long_desc>
                                Preserve the exact meaning of the analyzed program.
                            </long_desc>
                        </value>
                        <value>
                            <name>None</name>
                            <alias>none</alias>
                            <short_desc/>
                            <long_desc>
                                Change no modifiers whatsoever.
                            </long_desc>
                        </value>
                        <short_desc/>
                        <long_desc>
                            Specify which changes in visibility modifiers
                            are allowed.
                        </long_desc>
                    </multiopt>
                </sub_phase>
                <sub_phase>
                    <name>Static Inliner</name>
                    <class>SIOptions</class>
                    <alias>wjop.si</alias>
                    <short_desc>Static inliner: inlines monomorphic calls</short_desc>
                    <long_desc>
                        The Static Inliner visits all call sites in the call graph in a
                        bottom-up fashion, replacing monomorphic calls with inlined
                        copies of the invoked methods.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Reconstruct Jimple body after inlining</name>
                        <alias>rerun-jb</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc>
                            When a method with array parameters is inlined, its variables may need to
                            be assigned different types than they had in the original method to produce
                            compilable code. When this option is set, Soot re-runs the Jimple Body pack
                            on each method body which has had another method inlined into it so that
                            the typing algorithm can reassign the types.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>Insert Null Checks</name>
                        <alias>insert-null-checks</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc>
                            Insert, before the inlined body of the target method, a check
                            that throws a <tt>NullPointerException</tt> if the receiver
                            object is null. This ensures that inlining will not eliminate
                            exceptions which would have occurred in its absence.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>Insert Redundant Casts</name>
                        <alias>insert-redundant-casts</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc>
                            <p>
                                Insert extra casts for the Java bytecode verifier. The verifier
                                may complain if the inlined method uses <tt>this</tt> and the
                                declared type of the receiver of the call being inlined is
                                different from the type implementing the target method being
                                inlined.
                            </p>
                            <p>
                                Say, for example, that <tt>Singer</tt> is an interface declaring
                                the <tt>sing()</tt> method and that the call graph shows that all
                                receiver objects at a particular call site,
                                <tt>singer.sing()</tt>
                                (with <tt>singer</tt> declared as a
                                <tt>Singer</tt>) are in fact <tt>Bird</tt> objects (
                                <tt>Bird</tt>
                                being a class that implements <tt>Singer</tt>). The
                                implementation of <tt>Bird.sing()</tt> may perform operations on
                                <tt>this</tt>
                                which are only allowed on <tt>Bird</tt>s, rather
                                than <tt>Singer</tt>s. The Insert Redundant Casts option ensures that
                                this cannot lead to verification errors, by inserting a cast of
                                <tt>bird</tt>
                                to the <tt>Bird</tt> type before inlining the body
                                of <tt>Bird.sing()</tt>.
                            </p>
                        </long_desc>
                    </boolopt>
                    <multiopt>
                        <name>Allowed Modifier Changes</name>
                        <alias>allowed-modifier-changes</alias>
                        <value>
                            <name>Unsafe</name>
                            <alias>unsafe</alias>
                            <short_desc/>
                            <long_desc>
                                Modify the visibility on code so that all inlining is permitted.
                            </long_desc>
                            <default/>
                        </value>
                        <value>
                            <name>Safe</name>
                            <alias>safe</alias>
                            <short_desc/>
                            <long_desc>
                                Preserve the exact meaning of the analyzed program.
                            </long_desc>
                        </value>
                        <value>
                            <name>None</name>
                            <alias>none</alias>
                            <short_desc/>
                            <long_desc>
                                Change no modifiers whatsoever.
                            </long_desc>
                        </value>
                        <short_desc/>
                        <long_desc>
                            Specify which changes in visibility modifiers
                            are allowed.
                        </long_desc>
                    </multiopt>
                    <flopt>
                        <name>Expansion Factor</name>
                        <alias>expansion-factor</alias>
                        <default>3</default>
                        <short_desc/>
                        <long_desc>
                            Determines the maximum allowed expansion of a method. Inlining
                            will cause the method to grow by a factor of no more than
                            the Expansion Factor.
                        </long_desc>
                    </flopt>
                    <intopt>
                        <name>Max Container Size</name>
                        <alias>max-container-size</alias>
                        <default>5000</default>
                        <short_desc/>
                        <long_desc>
                            Determines the maximum number of Jimple statements for a container
                            method. If a method has more than this number of Jimple statements,
                            then no methods will be inlined into it.
                        </long_desc>
                    </intopt>
                    <intopt>
                        <name>Max Inlinee Size</name>
                        <alias>max-inlinee-size</alias>
                        <default>20</default>
                        <short_desc/>
                        <long_desc>
                            Determines the maximum number of Jimple statements for an inlinee
                            method. If a method has more than this number of Jimple statements,
                            then it will not be inlined into other methods.
                        </long_desc>
                    </intopt>
                </sub_phase>
            </phase>
            <phase>
                <name>Whole-Jimple Annotation Pack</name>
                <short_desc>Whole-jimple annotation pack: adds interprocedural tags</short_desc>
                <alias>wjap</alias>
                <long_desc>
                    <p>
                        Some analyses do not transform Jimple body directly, but annotate
                        statements or values with tags. Whole-Jimple annotation pack provides
                        a place for annotation-oriented analyses in whole program mode.
                    </p>
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>true</default>
                </boolopt>
                <sub_phase>
                    <name>Rectangular Array Finder</name>
                    <alias>wjap.ra</alias>
                    <short_desc>Rectangular array finder</short_desc>
                    <long_desc>
                        <p>
                            The Rectangular Array Finder traverses Jimple statements
                            based on the static call graph, and finds array variables which always
                            hold rectangular two-dimensional array objects.
                        </p>
                        <p>
                            In Java, a multi-dimensional array is an array of arrays, which
                            means the shape of the array can be ragged. Nevertheless, many
                            applications use rectangular arrays. Knowing that an array is
                            rectangular can be very helpful in proving safe array bounds
                            checks.
                        </p>
                        <p>
                            The Rectangular Array Finder does not change the
                            program being analyzed. Its results are used by the Array Bound
                            Checker.
                        </p>
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Unreachable Method Tagger</name>
                    <alias>wjap.umt</alias>
                    <short_desc>Tags all unreachable methods</short_desc>
                    <long_desc>
                        <p>Uses the call graph to determine which methods are unreachable and adds color tags so they
                            can be highlighted in a source browser.
                        </p>
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Unreachable Fields Tagger</name>
                    <alias>wjap.uft</alias>
                    <short_desc>Tags all unreachable fields</short_desc>
                    <long_desc>
                        <p>Uses the call graph to determine which fields are unreachable and adds color tags so they can
                            be highlighted in a source browser.
                        </p>
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Tightest Qualifiers Tagger</name>
                    <alias>wjap.tqt</alias>
                    <short_desc>Tags all qualifiers that could be tighter</short_desc>
                    <long_desc>
                        <p>Determines which methods and fields have qualifiers that could be tightened. For example: if
                            a field or method has the qualifier of public but is only used within the declaring class it
                            could be private. This, this field or method is tagged with color tags so that the results
                            can be highlighted in a source browser.
                        </p>
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Call Graph Grapher</name>
                    <class>CGGOptions</class>
                    <alias>wjap.cgg</alias>
                    <short_desc>Creates graphical call graph.</short_desc>
                    <long_desc>
                        <p>Creates graphical call graph.</p>
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                    <boolopt>
                        <name>Show Library Methods</name>
                        <alias>show-lib-meths</alias>
                        <default>false</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Purity Analysis [AM]</name>
                    <class>PurityOptions</class>
                    <alias>wjap.purity</alias>
                    <short_desc>Emit purity attributes</short_desc>
                    <long_desc>
                        Purity anaysis implemented by Antoine Mine and based on the paper
                        A Combined Pointer and Purity Analysis for Java Programs by
                        Alexandru Salcianu and Martin Rinard.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                    <boolopt>
                        <name>Dump one .dot files for each method summary</name>
                        <alias>dump-summaries</alias>
                        <default>true</default>
                    </boolopt>
                    <boolopt>
                        <name>Dump .dot call-graph annotated with method summaries (huge)</name>
                        <alias>dump-cg</alias>
                        <default>false</default>
                    </boolopt>
                    <boolopt>
                        <name>Dump one .dot for each intra-procedural method analysis (long)</name>
                        <alias>dump-intra</alias>
                        <default>false</default>
                    </boolopt>
                    <boolopt>
                        <name>Print analysis results</name>
                        <alias>print</alias>
                        <default>true</default>
                    </boolopt>
                    <boolopt>
                        <name>Annotate class files</name>
                        <short_desc>Marks pure methods with a purity bytecode attribute</short_desc>
                        <alias>annotate</alias>
                        <default>true</default>
                    </boolopt>
                    <boolopt>
                        <name>Be (quite) verbose</name>
                        <alias>verbose</alias>
                        <default>false</default>
                    </boolopt>
                </sub_phase>
            </phase>
            <phase>
                <name>Shimple Control</name>
                <alias>shimple</alias>
                <class>ShimpleOptions</class>
                <short_desc>Sets parameters for Shimple SSA form</short_desc>
                <long_desc>
                    <p>
                        Shimple Control sets parameters which apply throughout the
                        creation and manipulation of Shimple bodies. Shimple is Soot's
                        SSA representation.
                    </p>
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>true</default>
                </boolopt>
                <boolopt>
                    <name>Shimple Node Elimination Optimizations</name>
                    <alias>node-elim-opt</alias>
                    <short_desc>Node elimination optimizations</short_desc>
                    <default>true</default>
                    <long_desc>
                        <p>
                            Perform some optimizations, such as dead code elimination
                            and local aggregation, before/after eliminating nodes.
                        </p>
                    </long_desc>
                </boolopt>
                <boolopt>
                    <name>Local Name Standardization</name>
                    <alias>standard-local-names</alias>
                    <default>false</default>
                    <short_desc>Uses naming scheme of the Local Name
                        Standardizer.
                    </short_desc>
                    <long_desc>
                        If enabled, the Local Name Standardizer is applied whenever
                        Shimple creates new locals. Normally, Shimple will retain
                        the original local names as far as possible and use an
                        underscore notation to denote SSA subscripts. This
                        transformation does not otherwise affect Shimple
                        behaviour.
                    </long_desc>
                </boolopt>
                <boolopt>
                    <name>Extended SSA (SSI)</name>
                    <alias>extended</alias>
                    <default>false</default>
                    <short_desc>Compute extended SSA (SSI) form.</short_desc>
                    <long_desc>
                        If enabled, Shimple will create extended SSA (SSI) form.
                    </long_desc>
                </boolopt>
                <boolopt>
                    <name>Debugging Output</name>
                    <alias>debug</alias>
                    <default>false</default>
                    <short_desc>Enables debugging output, if any.</short_desc>
                    <long_desc>
                        If enabled, Soot may print out warnings and messages
                        useful for debugging the Shimple module. Automatically
                        enabled by the global debug switch.
                    </long_desc>
                </boolopt>
            </phase>

            <phase>
                <name>Shimple Transformation Pack</name>
                <alias>stp</alias>
                <short_desc>Shimple transformation pack</short_desc>
                <long_desc>
                    <p>
                        When the Shimple representation is produced, Soot applies the
                        contents of the Shimple Transformation Pack to each method
                        under analysis. This pack contains no transformations in an
                        unmodified version of Soot.
                    </p>
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>true</default>
                </boolopt>
            </phase>
            <phase>
                <name>Shimple Optimization Pack</name>
                <alias>sop</alias>
                <short_desc>Shimple optimization pack</short_desc>
                <long_desc>
                    <p>
                        The Shimple Optimization Pack contains transformations that
                        perform optimizations on Shimple, Soot's SSA
                        representation.
                    </p>
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>false</default>
                </boolopt>
                <sub_phase>
                    <name>Shimple Constant Propagator and Folder</name>
                    <short_desc>Shimple constant propagator and folder</short_desc>
                    <long_desc>
                        <p>
                            A powerful constant propagator and folder based on an
                            algorithm sketched by Cytron et al that takes
                            conditional control flow into account. This
                            optimization demonstrates some of the benefits of SSA
                            -- particularly the fact that Phi nodes represent
                            natural merge points in the control flow.
                        </p>
                    </long_desc>
                    <alias>sop.cpf</alias>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                    <boolopt>
                        <name>Prune Control Flow Graph</name>
                        <alias>prune-cfg</alias>
                        <default>true</default>
                        <short_desc>Take advantage of CFG optimization
                            opportunities.
                        </short_desc>
                        <long_desc>
                            <p>
                                Conditional branching statements that are found to
                                branch unconditionally (or fall through) are replaced
                                with unconditional branches (or removed). This
                                transformation exposes more opportunities for dead
                                code removal.
                            </p>
                        </long_desc>
                    </boolopt>
                </sub_phase>
            </phase>
            <phase>
                <name>Jimple Transformation Pack</name>
                <alias>jtp</alias>
                <short_desc>Jimple transformation pack: intraprocedural analyses added to Soot</short_desc>
                <long_desc>
                    Soot applies the contents of the Jimple Transformation Pack to
                    each method under analysis. This pack contains no
                    transformations in an unmodified version of Soot.
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>true</default>
                </boolopt>
            </phase>
            <phase>
                <name>Jimple Optimization Pack</name>
                <alias>jop</alias>
                <short_desc>Jimple optimization pack (intraprocedural)</short_desc>
                <long_desc>
                    When Soot's Optimize option is on, Soot applies the
                    Jimple Optimization Pack to every <tt>JimpleBody</tt> in
                    application classes. This section lists the default
                    transformations in the Jimple Optimization Pack.
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>false</default>
                    <short_desc>Eliminates common subexpressions</short_desc>
                    <long_desc/>
                </boolopt>
                <sub_phase>
                    <name>Common Subexpression Eliminator</name>
                    <alias>jop.cse</alias>
                    <short_desc>Common subexpression eliminator</short_desc>
                    <long_desc>
                        <p>
                            The Common Subexpression Eliminator runs an available expressions
                            analysis on the method body, then eliminates common
                            subexpressions.
                        </p>
                        <p>
                            This implementation is especially slow, as it runs on individual
                            statements rather than on basic blocks. A better implementation
                            (which would find most common subexpressions, but not all) would use
                            basic blocks instead.
                        </p>
                        <p>
                            This implementation is also slow because the flow universe is
                            explicitly created; it need not be. A better implementation
                            would implicitly compute the kill sets at every node.
                        </p>
                        <p>
                            Because of its current slowness, this transformation is not
                            enabled by default.
                        </p>
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Naive Side Effect Tester</name>
                        <alias>naive-side-effect</alias>
                        <default>false</default>
                        <short_desc>Use naive side effect analysis even if interprocedural information is available
                        </short_desc>
                        <long_desc>
                            <p>
                                If Naive Side Effect Tester is <tt>true</tt>, the Common
                                Subexpression Eliminator uses the conservative side effect
                                information provided by the <tt>NaiveSideEffectTester</tt> class,
                                even if interprocedural information about side effects is
                                available.
                            </p>
                            <p>
                                The naive side effect analysis is based solely on the information
                                available locally about a statement. It assumes, for example,
                                that any method call has the potential to write and read all
                                instance and static fields in the program.
                            </p>
                            <p>
                                If Naive Side Effect Tester is set to <tt>false</tt> and Soot is
                                in whole program mode, then the Common Subexpression
                                Eliminator uses the side effect information provided by the
                                <tt>PASideEffectTester</tt>
                                class.
                                <tt>PASideEffectTester</tt>
                                uses a points-to analysis to
                                determine which fields and statics may be written or read by a
                                given statement.
                            </p>
                            <p>
                                If whole program analysis is not performed, naive side effect
                                information is used regardless of the setting of
                                Naive Side Effect Tester.
                            </p>
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Busy Code Motion</name>
                    <alias>jop.bcm</alias>
                    <class>BCMOptions</class>
                    <short_desc>Busy code motion: unaggressive partial redundancy elimination</short_desc>
                    <long_desc>
                        Busy Code Motion is a straightforward implementation of Partial
                        Redundancy Elimination. This implementation is not very
                        aggressive. Lazy Code Motion is an improved version which
                        should be used instead of Busy Code Motion.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Naive Side Effect Tester</name>
                        <alias>naive-side-effect</alias>
                        <default>false</default>
                        <short_desc>Use a naive side effect analysis even if interprocedural information is available
                        </short_desc>
                        <long_desc>
                            <p>
                                If Naive Side Effect Tester is set to <tt>true</tt>, Busy Code
                                Motion uses the conservative side effect information provided by
                                the <tt>NaiveSideEffectTester</tt> class, even if interprocedural
                                information about side effects is available.
                            </p>
                            <p>
                                The naive side effect analysis is based solely on the information
                                available locally about a statement. It assumes, for example,
                                that any method call has the potential to write and read all
                                instance and static fields in the program.
                            </p>
                            <p>
                                If Naive Side Effect Tester is set to <tt>false</tt> and Soot is
                                in whole program mode, then Busy Code Motion uses the side effect
                                information provided by the
                                <tt>PASideEffectTester</tt>
                                class. <tt>PASideEffectTester</tt> uses a points-to analysis to
                                determine which fields and statics may be written or read by a
                                given statement.
                            </p>
                            <p>
                                If whole program analysis is not performed, naive side effect
                                information is used regardless of the setting of
                                Naive Side Effect Tester.
                            </p>
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Lazy Code Motion</name>
                    <class>LCMOptions</class>
                    <alias>jop.lcm</alias>
                    <short_desc>Lazy code motion: aggressive partial redundancy elimination</short_desc>
                    <long_desc>
                        Lazy Code Motion is an enhanced version of Busy Code Motion, a
                        Partial Redundancy Eliminator. Before doing Partial Redundancy Elimination,
                        this optimization performs loop inversion (turning <tt>while</tt> loops
                        into <tt>do while</tt> loops inside an <tt>if</tt> statement).
                        This allows the Partial Redundancy Eliminator
                        to optimize loop invariants of <tt>while</tt> loops.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <multiopt>
                        <name>Safety</name>
                        <alias>safety</alias>
                        <value>
                            <name>Safe</name>
                            <alias>safe</alias>
                            <short_desc/>
                            <long_desc>
                                Safe, but only considers moving additions,
                                subtractions and multiplications.
                            </long_desc>
                            <default/>
                        </value>
                        <value>
                            <name>Medium</name>
                            <alias>medium</alias>
                            <short_desc/>
                            <long_desc>
                                Unsafe in multi-threaded programs, as it may reuse the values
                                read from field accesses.
                            </long_desc>
                        </value>
                        <value>
                            <name>Unsafe</name>
                            <alias>unsafe</alias>
                            <short_desc/>
                            <long_desc>
                                May violate Java's exception semantics, as it may move or reorder
                                exception-throwing statements, potentially outside of
                                <tt>try-catch</tt>
                                blocks.
                            </long_desc>
                        </value>
                        <short_desc/>
                        <long_desc>
                            This option controls which fields and statements are candidates
                            for code motion.
                        </long_desc>
                    </multiopt>
                    <boolopt>
                        <name>Unroll</name>
                        <alias>unroll</alias>
                        <short_desc/>
                        <long_desc>
                            If <tt>true</tt>, perform loop inversion before doing the
                            transformation.
                        </long_desc>
                        <default>true</default>
                    </boolopt>
                    <boolopt>
                        <name>Naive Side Effect Tester</name>
                        <alias>naive-side-effect</alias>
                        <default>false</default>
                        <short_desc>Use a naive side effect analysis even if interprocedural information is available
                        </short_desc>
                        <long_desc>
                            <p>
                                If Naive Side Effect Tester is set to <tt>true</tt>, Lazy Code
                                Motion uses the conservative side effect information provided by
                                the <tt>NaiveSideEffectTester</tt> class, even if interprocedural
                                information about side effects is available.
                            </p>
                            <p>
                                The naive side effect analysis is based solely on the information
                                available locally about a statement. It assumes, for example,
                                that any method call has the potential to write and read all
                                instance and static fields in the program.
                            </p>
                            <p>
                                If Naive Side Effect Tester is set to <tt>false</tt> and Soot is
                                in whole program mode, then Lazy Code Motion uses the side effect
                                information provided by the
                                <tt>PASideEffectTester</tt>
                                class. <tt>PASideEffectTester</tt> uses a points-to analysis to
                                determine which fields and statics may be written or read by a
                                given statement.
                            </p>
                            <p>
                                If whole program analysis is not performed, naive side effect
                                information is used regardless of the setting of
                                Naive Side Effect Tester.
                            </p>
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Copy Propagator</name>
                    <class>CPOptions</class>
                    <alias>jop.cp</alias>
                    <short_desc>Copy propagator</short_desc>
                    <long_desc>
                        <p>
                            This phase performs cascaded copy propagation.
                        </p>
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Only Regular Locals</name>
                        <alias>only-regular-locals</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc>
                            Only propagate copies through ``regular&apos;&apos; locals, that is,
                            those declared in the source bytecode.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>Only Stack Locals</name>
                        <alias>only-stack-locals</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc>
                            Only propagate copies through locals that represent stack locations in
                            the original bytecode.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Jimple Constant Propagator and Folder</name>
                    <alias>jop.cpf</alias>
                    <short_desc>Constant propagator and folder</short_desc>
                    <long_desc>
                        The Jimple Constant Propagator and Folder evaluates any expressions
                        consisting entirely of compile-time constants, for example <tt>2
                        * 3</tt>, and replaces the expression with the constant result,
                        in this case <tt>6</tt>.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Conditional Branch Folder</name>
                    <alias>jop.cbf</alias>
                    <short_desc>Conditional branch folder</short_desc>
                    <long_desc>
                        The Conditional Branch Folder statically evaluates the
                        conditional expression of Jimple <tt>if</tt> statements. If the
                        condition is identically <tt>true</tt> or
                        <tt>false</tt>, the Folder replaces the conditional branch
                        statement with an unconditional <tt>goto</tt> statement.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Dead Assignment Eliminator</name>
                    <alias>jop.dae</alias>
                    <short_desc>Dead assignment eliminator</short_desc>
                    <long_desc>
                        The Dead Assignment Eliminator eliminates assignment statements
                        to locals whose values are not subsequently used, unless
                        evaluating the right-hand side of the assignment may cause
                        side-effects.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Only Tag Dead Code</name>
                        <alias>only-tag</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc>
                            Only tag dead assignment statements instead of eliminaing them.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>Only Stack Locals</name>
                        <alias>only-stack-locals</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc>
                            Only eliminate dead assignments to locals that represent stack
                            locations in the original bytecode.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Null Check Eliminator</name>
                    <alias>jop.nce</alias>
                    <short_desc>Null Check Eliminator</short_desc>
                    <long_desc>
                        Replaces statements 'if(x!=null) goto y' with 'goto y' if x is
                        known to be non-null or with 'nop' if it is known to be null,
                        etc. Generates dead code and is hence followed by unreachable
                        code elimination. Disabled by default because it can be
                        expensive on methods with many locals.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Unreachable Code Eliminator 1</name>
                    <alias>jop.uce1</alias>
                    <short_desc>Unreachable code eliminator, pass 1</short_desc>
                    <long_desc>
                        The Unreachable Code Eliminator removes unreachable code and
                        traps whose catch blocks are empty.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Remove unreachable traps</name>
                        <alias>remove-unreachable-traps</alias>
                        <default>false</default>
                        <long_desc>
                            Remove exception table entries when none of the protected instructions can
                            throw the exception being caught.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Unconditional Branch Folder 1</name>
                    <alias>jop.ubf1</alias>
                    <short_desc>Unconditional branch folder, pass 1</short_desc>
                    <long_desc>
                        <p>
                            The Unconditional Branch Folder removes unnecessary `<tt>goto</tt>&apos;
                            statements from a <tt>JimpleBody</tt>.
                        </p>
                        <p>
                            If a <tt>goto</tt> statement's target is the next instruction,
                            then the statement is removed. If a <tt>goto</tt>'s target is
                            another <tt>goto</tt>, with target <tt>y</tt>, then the first
                            statement's target is changed to <tt>y</tt>.
                        </p>
                        <p>
                            If some <tt>if</tt> statement's target is a
                            <tt>goto</tt>
                            statement, then the <tt>if</tt>'s target can be replaced with the
                            <tt>goto</tt>'s target.
                        </p>
                        <p>
                            (These situations can result from other optimizations, and branch
                            folding may itself generate more unreachable code.)
                        </p>
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Unreachable Code Eliminator 2</name>
                    <alias>jop.uce2</alias>
                    <short_desc>Unreachable code eliminator, pass 2</short_desc>
                    <long_desc>
                        Another iteration of the Unreachable Code Eliminator.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Remove unreachable traps</name>
                        <alias>remove-unreachable-traps</alias>
                        <default>false</default>
                        <long_desc>
                            Remove exception table entries when none of the protected instructions can
                            throw the exception being caught.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Unconditional Branch Folder 2</name>
                    <alias>jop.ubf2</alias>
                    <short_desc>Unconditional branch folder, pass 2</short_desc>
                    <long_desc>
                        Another iteration of the Unconditional Branch Folder.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Unused Local Eliminator</name>
                    <alias>jop.ule</alias>
                    <short_desc>Unused local eliminator</short_desc>
                    <long_desc>
                        The Unused Local Eliminator phase removes any unused locals from
                        the method.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                </sub_phase>
            </phase>
            <phase>
                <name>Jimple Annotation Pack</name>
                <alias>jap</alias>
                <short_desc>Jimple annotation pack: adds intraprocedural tags</short_desc>
                <long_desc>
                    The Jimple Annotation Pack contains phases which add annotations
                    to Jimple bodies individually (as opposed to the Whole-Jimple
                    Annotation Pack, which adds annotations based on the analysis of
                    the whole program).
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>true</default>
                </boolopt>
                <sub_phase>
                    <name>Null Pointer Checker</name>
                    <class>NPCOptions</class>
                    <alias>jap.npc</alias>
                    <short_desc>Null pointer checker</short_desc>
                    <long_desc>
                        The Null Pointer Checker finds instruction which have the potential
                        to throw <tt>NullPointerException</tt>s and adds annotations
                        indicating whether or not the pointer being dereferenced can be
                        determined statically not to be null.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Only Array Ref</name>
                        <alias>only-array-ref</alias>
                        <default>false</default>
                        <short_desc>Annotate only array references</short_desc>
                        <long_desc>
                            Annotate only array-referencing instructions, instead of all
                            instructions that need null pointer checks.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>Profiling</name>
                        <alias>profiling</alias>
                        <default>false</default>
                        <short_desc>Insert instructions to count safe pointer accesses</short_desc>
                        <long_desc>
                            <p>
                                Insert profiling instructions that at runtime count the number of
                                eliminated safe null pointer checks. The inserted profiling code
                                assumes the existence of a <tt>MultiCounter</tt> class
                                implementing the methods invoked. For details, see the
                                <tt>NullPointerChecker</tt>
                                source code.
                            </p>
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Null Pointer Colourer</name>
                    <alias>jap.npcolorer</alias>
                    <default>true</default>
                    <short_desc>Null pointer colourer: tags references for eclipse</short_desc>
                    <long_desc>
                        Produce colour tags that the Soot plug-in for Eclipse can use to
                        highlight null and non-null references.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <long_desc></long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Array Bound Checker</name>
                    <class>ABCOptions</class>
                    <alias>jap.abc</alias>
                    <short_desc>Array bound checker</short_desc>
                    <long_desc>
                        <p>
                            The Array Bound Checker performs a static analysis to determine
                            which array bounds checks may safely be eliminated and then annotates
                            statements with the results of the analysis.
                        </p>
                        <p>
                            If Soot is in whole-program mode, the Array Bound Checker can
                            use the results provided by the Rectangular Array Finder.
                        </p>
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>With All</name>
                        <alias>with-all</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc>
                            <p>
                                Setting the With All option to true is equivalent to setting each
                                of With CSE, With Array Ref, With Field Ref,
                                With Class Field, and With Rectangular Array to true.
                            </p>
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>With Common Sub-expressions</name>
                        <alias>with-cse</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc>
                            <p>
                                The analysis will consider common subexpressions. For example,
                                consider the situation where <tt>r1</tt> is assigned
                                <tt>a*b</tt>; later, <tt>r2</tt> is assigned <tt>a*b</tt>, where
                                neither <tt>a</tt> nor <tt>b</tt> have changed between the two
                                statements. The analysis can conclude that <tt>r2</tt> has the
                                same value as <tt>r1</tt>. Experiments show that this option can
                                improve the result slightly.
                            </p>
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>With Array References</name>
                        <alias>with-arrayref</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc>
                            <p>
                                With this option enabled, array references can be considered as
                                common subexpressions; however, we are more conservative when
                                writing into an array, because array objects may be aliased. We
                                also assume that the application is single-threaded or that the
                                array references occur in a synchronized block. That is, we
                                assume that an array element may not be changed by other threads
                                between two array references.
                            </p>
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>With Field References</name>
                        <alias>with-fieldref</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc>
                            <p>
                                The analysis treats field references (static and instance) as
                                common subexpressions; however, we are more conservative when
                                writing to a field, because the base of the field reference may
                                be aliased. We also assume that the application is
                                single-threaded or that the field references occur in a
                                synchronized block. That is, we assume that a field may
                                not be changed by other threads between two field references.
                            </p>
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>With Class Field</name>
                        <alias>with-classfield</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc>
                            <p>
                                This option makes the analysis work on the class level. The
                                algorithm analyzes <tt>final</tt> or <tt>private</tt> class
                                fields first. It can recognize the fields that hold array objects
                                of constant length. In an application using lots of array
                                fields, this option can improve the analysis results
                                dramatically.
                            </p>
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>With Rectangular Array</name>
                        <alias>with-rectarray</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc>
                            This option is used together with <tt>wjap.ra</tt> to make Soot run the whole-program
                            analysis for rectangular array objects. This analysis is based on the
                            call graph, and it usually takes a long time. If the application uses
                            rectangular arrays, these options can improve the analysis
                            result.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>Profiling</name>
                        <alias>profiling</alias>
                        <default>false</default>
                        <short_desc>Profile the results of array bounds check analysis.</short_desc>
                        <long_desc>
                            <p>
                                Profile the results of array bounds check analysis. The inserted
                                profiling code assumes the existence of a
                                <tt>MultiCounter</tt>
                                class implementing the methods invoked. For details, see the
                                <tt>ArrayBoundsChecker</tt>
                                source code.
                            </p>
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>Add Color Tags</name>
                        <alias>add-color-tags</alias>
                        <default>false</default>
                        <short_desc>Add color tags to results of array bound check analysis.</short_desc>
                        <long_desc>Add color tags to the results of the array bounds check analysis.</long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Profiling Generator</name>
                    <alias>jap.profiling</alias>
                    <class>ProfilingOptions</class>
                    <short_desc>Instruments null pointer and array checks</short_desc>
                    <long_desc>
                        <p>
                            The Profiling Generator inserts the method invocations required
                            to initialize and to report the results of any profiling
                            performed by the Null Pointer Checker and Array Bound
                            Checker. Users of the Profiling Generator must provide a
                            <tt>MultiCounter</tt>
                            class implementing the methods invoked. For
                            details, see the <tt>ProfilingGenerator</tt> source code.
                        </p>
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Not Main Entry</name>
                        <alias>notmainentry</alias>
                        <default>false</default>
                        <short_desc>Instrument <tt>runBenchmark()</tt> instead of
                            <tt>main()</tt>
                        </short_desc>
                        <long_desc>
                            <p>
                                Insert the calls to the <tt>MultiCounter</tt> at the
                                beginning and end of methods with the signature
                                <tt>long runBenchmark(java.lang.String[])</tt>
                                instead of the signature
                                <tt>void main(java.lang.String[])</tt>.
                            </p>
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Side Effect tagger</name>
                    <alias>jap.sea</alias>
                    <class>SETOptions</class>
                    <short_desc>Side effect tagger</short_desc>
                    <long_desc>
                        <p>
                            The Side Effect Tagger
                            uses the active invoke graph to produce side-effect attributes, as
                            described in the <a
                                href="http://www.sable.mcgill.ca/publications/thesis/#olhotakMastersThesis">Spark
                            thesis</a>, chapter 6.
                        </p>
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Build naive dependence graph</name>
                        <alias>naive</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc>
                            <p>
                                When set to true, the dependence graph is built with a node for
                                each statement, without merging the nodes for equivalent
                                statements. This makes it possible to measure the effect of
                                merging nodes for equivalent statements on the size of the
                                dependence graph.
                            </p>
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Field Read/Write Tagger</name>
                    <class>FRWOptions</class>
                    <alias>jap.fieldrw</alias>
                    <short_desc>Field read/write tagger</short_desc>
                    <long_desc>
                        <p>
                            The Field Read/Write Tagger uses the active invoke graph to
                            produce tags indicating which fields may be read or written by
                            each statement, including invoke statements.
                        </p>
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <intopt>
                        <name>Maximum number of fields</name>
                        <alias>threshold</alias>
                        <default>100</default>
                        <short_desc/>
                        <long_desc>
                            If a statement reads/writes more than this number of fields, no tag will be
                            produced for it, in order to keep the size of the tags reasonable.
                        </long_desc>
                    </intopt>
                </sub_phase>
                <sub_phase>
                    <name>Call Graph Tagger</name>
                    <alias>jap.cgtagger</alias>
                    <short_desc>Call graph tagger</short_desc>
                    <long_desc>
                        The Call Graph Tagger produces LinkTags based on the call
                        graph. The Eclipse plugin uses these tags to produce
                        linked popup lists which indicate the source and target methods
                        of the statement. Selecting a link from the list moves the
                        cursor to the indicated method.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Parity Tagger</name>
                    <alias>jap.parity</alias>
                    <short_desc>Parity tagger</short_desc>
                    <long_desc>
                        The Parity Tagger produces StringTags and ColorTags indicating
                        the parity of a variable (even, odd, top, or bottom). The eclipse
                        plugin can use tooltips and variable colouring to display the
                        information in these tags. For example, even variables (such as
                        <tt>x</tt>
                        in <tt>x = 2</tt>) are coloured yellow.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Parameter Alias Tagger</name>
                    <alias>jap.pat</alias>
                    <short_desc>Colour-codes method parameters that may be aliased</short_desc>
                    <long_desc>For each method with parameters of reference type, this tagger indicates the aliasing
                        relationships between the parameters using colour tags. Parameters that may be aliased are the
                        same colour. Parameters that may not be aliased are in different colours.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Live Variables Tagger</name>
                    <alias>jap.lvtagger</alias>
                    <short_desc>Creates color tags for live variables</short_desc>
                    <long_desc>Colors live variables.</long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Reaching Defs Tagger</name>
                    <alias>jap.rdtagger</alias>
                    <short_desc>Creates link tags for reaching defs</short_desc>
                    <long_desc>For each use of a local in a stmt creates a link to the reaching def.</long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Cast Elimination Check Tagger</name>
                    <alias>jap.che</alias>
                    <short_desc>Indicates whether cast checks can be eliminated</short_desc>
                    <long_desc>Indicates whether cast checks can be eliminated.</long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Unreachable Method Transformer</name>
                    <alias>jap.umt</alias>
                    <short_desc>Inserts assertions into unreachable methods</short_desc>
                    <long_desc>When the whole-program analysis determines a method to be unreachable, this transformer
                        inserts an assertion into the method to check that it is indeed unreachable.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Loop Invariant Tagger</name>
                    <alias>jap.lit</alias>
                    <short_desc>Tags loop invariants</short_desc>
                    <long_desc>An expression whose operands are constant or have reaching definitions from outside the
                        loop body are tagged as loop invariant.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Available Expressions Tagger</name>
                    <class>AETOptions</class>
                    <alias>jap.aet</alias>
                    <short_desc>Tags statements with sets of available expressions</short_desc>
                    <long_desc>A each statement a set of available expressions is after the statement is added as a
                        tag.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                    <multiopt>
                        <name>Kind</name>
                        <alias>kind</alias>
                        <value>
                            <name>Optimistic</name>
                            <alias>optimistic</alias>
                            <default/>
                        </value>
                        <value>
                            <name>Pessimistic</name>
                            <alias>pessimistic</alias>
                        </value>
                    </multiopt>
                </sub_phase>
                <sub_phase>
                    <name>Dominators Tagger</name>
                    <alias>jap.dmt</alias>
                    <short_desc>Tags dominators of statement</short_desc>
                    <long_desc>Provides link tags at a statement to all of the satements dominators.</long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                    </boolopt>
                </sub_phase>
            </phase>
            <!--<phase>
                <name>CFG Viewer</name>
                <alias>cfg</alias>
                <short_desc>Produces CFGs for viewing purposes</short_desc>
                <long_desc>Produces CFGs in the form of dot files when run from the command line runs or graphs when run from within Eclipse.</long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>false</default>
                    <short_desc/>
                    <long_desc/>
                </boolopt>
                <sub_phase>
                    <name>CFG Output Options</name>
                    <class>CFGOutputOptions</class>
                    <alias>cfg.output</alias>
                    <short_desc>Determines the type of graphs to output</short_desc>
                    <long_desc>Determines the type of graphs to output</long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>

                    <multiopt>
                        <name>Graph Type</name>
                        <alias>graph-type</alias>
                        <short_desc>Determines which type of graph to output</short_desc>
                        <long_desc>Determines which type of graph to output based on whether nodes are units or blocks and whether control flow associated with Exceptions is taken into consideration or not.</long_desc>
                        <value>
                            <name>Complete Unit Graph</name>
                            <alias>complete-unit-graph</alias>
                            <short_desc>Output a complete Unit Graph</short_desc>
                            <long_desc>Output a complete Unit Graph, where nodes are units and control flow associated with Exceptions is taken into account.</long_desc>
                            <default/>
                        </value>
                        <value>
                            <name>Unit Graph</name>
                            <alias>unit-graph</alias>
                            <short_desc>Output a Unit Graph</short_desc>
                            <long_desc>Output a Unit Graph, where nodes are units and control flow associated with Exceptions is not taken into account.</long_desc>
                        </value>
                        <value>
                            <name>Complete Block Graph</name>
                            <alias>complete-block-graph</alias>
                            <short_desc>Output a complete Block Graph</short_desc>
                            <long_desc>Output a complete Block Graph, where nodes are blocks and control flow associated with Exceptions is taken into account.</long_desc>
                        </value>
                        <value>
                            <name>Brief Block Graph</name>
                            <alias>brief-block-graph</alias>
                            <short_desc>Output a brief Block Graph</short_desc>
                            <long_desc>Output a brief Block Graph, where nodes are blocks and control flow associated with Exceptions is ignored.</long_desc>
                        </value>
                        <value>
                            <name>Array Block Graph</name>
                            <alias>array-block-graph</alias>
                            <short_desc>Output an array Block Graph</short_desc>
                            <long_desc>Output an array Block Graph</long_desc>
                        </value>
                    </multiopt>
                    <multiopt>
                        <name>Output Type</name>
                        <alias>output-type</alias>
                        <short_desc>Determines which type of files to generate</short_desc>
                        <long_desc>Determines which type of files to generate</long_desc>
                        <value>
                            <name>Dot Files</name>
                            <alias>dot-files</alias>
                            <short_desc>Generate graphs as dot files</short_desc>
                            <long_desc>Generate graphs as dot files that can be then be converted to post-script for viewing.</long_desc>
                         </value>
                         <value>
                            <name>Eclipse Graphs</name>
                            <alias>eclipse-graphs</alias>
                            <short_desc>Generate graphs that can be manipulated within Eclipse</short_desc>
                            <long_desc>Generate graphs that can be manipulated within Eclipse.</long_desc>
                           </value>
                           </multiopt>
               </sub_phase>
            </phase>-->
            <phase>
                <name>Grimp Body Creation</name>
                <alias>gb</alias>
                <short_desc>Creates a GrimpBody for each method</short_desc>
                <long_desc>
                    The Grimp Body Creation phase creates a <tt>GrimpBody</tt> for
                    each source method. It is run only if the output format is
                    <tt>grimp</tt>
                    or <tt>grimple</tt>, or if class files are being
                    output and the Via Grimp option has been specified.
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>true</default>
                    <short_desc/>
                    <long_desc/>
                </boolopt>
                <sub_phase>
                    <name>Grimp Pre-folding Aggregator</name>
                    <alias>gb.a1</alias>
                    <short_desc>Aggregator: removes some copies, pre-folding</short_desc>
                    <long_desc>
                        The Grimp Pre-folding Aggregator combines some local variables,
                        finding definitions with only a single use and removing the
                        definition after replacing the use with the definition's
                        right-hand side, if it is safe to do so. While the mechanism is
                        the same as that employed by the Jimple Local Aggregator, there
                        is more scope for aggregation because of Grimp's more complicated
                        expressions.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Only Stack Locals</name>
                        <alias>only-stack-locals</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc>
                            Aggregate only values stored in stack locals.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Grimp Constructor Folder</name>
                    <alias>gb.cf</alias>
                    <short_desc>Constructor folder</short_desc>
                    <long_desc>
                        The Grimp Constructor Folder combines <tt>new</tt> statements
                        with the <tt>specialinvoke</tt> statement that calls the new
                        object's constructor. For example, it turns
                        <pre>
                            r2 = new java.util.ArrayList;
                            r2.<lt/>init<gt/>();
                        </pre>
                        into
                        <pre>
                            r2 = new java.util.ArrayList();
                        </pre>
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Grimp Post-folding Aggregator</name>
                    <alias>gb.a2</alias>
                    <short_desc>Aggregator: removes some copies, post-folding</short_desc>
                    <long_desc>
                        The Grimp Post-folding Aggregator combines local variables after
                        constructors have been folded. Constructor folding typically
                        introduces new opportunities for aggregation, since when a
                        sequence of instructions like
                        <pre>
                            r2 = new java.util.ArrayList;
                            r2.<lt/>init<gt/>();
                            r3 = r2
                        </pre>
                        is replaced by
                        <pre>
                            r2 = new java.util.ArrayList();
                            r3 = r2
                        </pre>the invocation of
                        <tt><lt/>init
                            <gt/>
                        </tt>
                        no longer represents a potential side-effect
                        separating the two definitions, so they can be combined into
                        <pre>
                            r3 = new java.util.ArrayList();
                        </pre>(assuming there are no subsequent uses of <tt>r2</tt>).
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                    <boolopt>
                        <name>Only Stack Locals</name>
                        <alias>only-stack-locals</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc>
                            Aggregate only values stored in stack locals.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Grimp Unused Local Eliminator</name>
                    <alias>gb.ule</alias>
                    <short_desc>Unused local eliminator</short_desc>
                    <long_desc>
                        This phase removes any locals that are unused after constructor
                        folding and aggregation.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                </sub_phase>
            </phase>
            <phase>
                <name>Grimp Optimization</name>
                <alias>gop</alias>
                <short_desc>Grimp optimization pack</short_desc>
                <long_desc>
                    The Grimp Optimization pack performs optimizations on
                    <tt>GrimpBody</tt>s (currently there are no optimizations
                    performed specifically on <tt>GrimpBody</tt>s, and the pack is
                    empty). It is run only if the output format is <tt>grimp</tt> or
                    <tt>grimple</tt>, or if class files are being output and the Via
                    Grimp option has been specified.
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>false</default>
                </boolopt>
            </phase>
            <phase>
                <name>Baf Body Creation</name>
                <alias>bb</alias>
                <short_desc>Creates Baf bodies</short_desc>
                <long_desc>
                    The Baf Body Creation phase creates a
                    <tt>BafBody</tt>
                    from each source method. It is
                    run if the output format is <tt>baf</tt> or <tt>b</tt> or <tt>asm</tt> or <tt>a</tt>, or
                    if class files are being output and the Via Grimp option
                    has not been specified.
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>true</default>
                </boolopt>
                <sub_phase>
                    <name>Load Store Optimizer</name>
                    <alias>bb.lso</alias>
                    <short_desc>Load store optimizer</short_desc>
                    <long_desc>
                        The Load Store Optimizer replaces some combinations of loads to and stores from local variables
                        with stack instructions. A simple example would be the replacement of
                        <pre>
                            store.r $r2;
                            load.r $r2;
                        </pre>
                        with
                        <pre>
                            dup1.r
                        </pre>
                        in cases where the value of
                        <tt><dollar/>r2
                        </tt>
                        is not used subsequently.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                    <boolopt>
                        <name>Debug</name>
                        <alias>debug</alias>
                        <default>false</default>
                        <long_desc>
                            Produces voluminous debugging output describing the progress of
                            the load store optimizer.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>Inter</name>
                        <alias>inter</alias>
                        <default>false</default>
                        <long_desc>
                            Enables two simple inter-block optimizations which attempt to
                            keep some variables on the stack between blocks. Both are
                            intended to catch <tt>if</tt>-like constructions where control
                            flow branches temporarily into two paths that converge at a later
                            point.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>sl</name>
                        <alias>sl</alias>
                        <default>true</default>
                        <long_desc>
                            Enables an optimization which attempts to eliminate
                            <tt>store</tt>/<tt>load</tt> pairs.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>sl2</name>
                        <alias>sl2</alias>
                        <default>false</default>
                        <long_desc>
                            Enables an a second pass of the optimization which attempts to
                            eliminate <tt>store</tt>/<tt>load</tt> pairs.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>sll</name>
                        <alias>sll</alias>
                        <default>true</default>
                        <long_desc>
                            Enables an optimization which attempts to eliminate
                            <tt>store</tt>/<tt>load</tt>/
                            <tt>load</tt>
                            trios with some variant of <tt>dup</tt>.
                        </long_desc>
                    </boolopt>
                    <boolopt>
                        <name>sll2</name>
                        <alias>sll2</alias>
                        <default>false</default>
                        <long_desc>
                            Enables an a second pass of the optimization which attempts to
                            eliminate <tt>store</tt>/<tt>load</tt>/<tt>load</tt> trios with
                            some variant of <tt>dup</tt>.
                        </long_desc>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Store Chain Optimizer</name>
                    <alias>bb.sco</alias>
                    <short_desc>Store chain optimizer</short_desc>
                    <long_desc>
                        The store chain optimizer detects chains of push/store pairs that write to the same variable and
                        only retains the last store. It removes the unnecessary previous push/stores that are
                        subsequently overwritten.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Peephole Optimizer</name>
                    <alias>bb.pho</alias>
                    <short_desc>Peephole optimizer</short_desc>
                    <long_desc>
                        Applies peephole optimizations to the Baf intermediate
                        representation. Individual optimizations must be implemented by
                        classes implementing the <tt>Peephole</tt> interface. The
                        Peephole Optimizer reads the names of the
                        <tt>Peephole</tt>
                        classes at runtime from the file <tt>peephole.dat</tt> and loads
                        them dynamically. Then it continues to apply the
                        <tt>Peephole</tt>s repeatedly until none of them are able to
                        perform any further optimizations.
                        <p>
                            Soot provides only one <tt>Peephole</tt>, named
                            <tt>ExamplePeephole</tt>, which is not enabled by the delivered
                            <tt>peephole.dat</tt>
                            file.
                            <tt>ExamplePeephole</tt>
                            removes all
                            <tt>checkcast</tt>
                            instructions.
                        </p>
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Unused Local Eliminator</name>
                    <alias>bb.ule</alias>
                    <short_desc>Unused local eliminator</short_desc>
                    <long_desc>
                        This phase removes any locals that are unused after load store optimization
                        and peephole optimization.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Local Packer</name>
                    <alias>bb.lp</alias>
                    <short_desc>Local packer: minimizes number of locals</short_desc>
                    <long_desc>
                        The Local Packer attempts to minimize the number of local
                        variables required in a method by reusing the same variable for
                        disjoint DU-UD webs. Conceptually, it is the inverse of the
                        Local Splitter.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                    </boolopt>
                    <boolopt>
                        <name>Unsplit Original Locals</name>
                        <alias>unsplit-original-locals</alias>
                        <default>false</default>
                        <long_desc>
                            Use the variable names in the original source as a guide when
                            determining how to share local variables across non-interfering
                            variable usages. This recombines named locals which were split by
                            the Local Splitter.
                        </long_desc>
                    </boolopt>
                </sub_phase>
            </phase>
            <phase>
                <name>Baf Optimization</name>
                <alias>bop</alias>
                <short_desc>Baf optimization pack</short_desc>
                <long_desc>
                    The Baf Optimization pack performs optimizations on
                    <tt>BafBody</tt>s (currently there are no optimizations performed
                    specifically on <tt>BafBody</tt>s, and the pack is empty). It is
                    run only if the output format is <tt>baf</tt> or <tt>b</tt> or <tt>asm</tt> or <tt>a</tt>, or
                    if class files are being output and the Via Grimp option
                    has not been specified.
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>false</default>
                </boolopt>
            </phase>
            <phase>
                <name>Tag Aggregator</name>
                <alias>tag</alias>
                <short_desc>Tag aggregator: turns tags into attributes</short_desc>
                <long_desc>
                    <p>
                        The Tag Aggregator pack aggregates tags attached to individual units
                        into a code attribute for each method, so that these attributes can be
                        encoded in Java class files.
                    </p>
                </long_desc>
                <boolopt>
                    <name>Enabled</name>
                    <alias>enabled</alias>
                    <default>true</default>
                </boolopt>
                <sub_phase>
                    <name>Line Number Tag Aggregator</name>
                    <alias>tag.ln</alias>
                    <short_desc>Line number aggregator</short_desc>
                    <long_desc>
                        <p>
                            The Line Number Tag Aggregator aggregates line number
                            tags.
                        </p>
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>true</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Array Bounds and Null Pointer Check Tag Aggregator</name>
                    <alias>tag.an</alias>
                    <short_desc>Array bounds and null pointer check aggregator</short_desc>
                    <long_desc>
                        <p>
                            The Array Bounds and Null Pointer Tag Aggregator aggregates
                            tags produced by the Array Bound Checker and Null Pointer Checker.
                        </p>
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Dependence Tag Aggregator</name>
                    <alias>tag.dep</alias>
                    <short_desc>Dependence aggregator</short_desc>
                    <long_desc>
                        <p>
                            The Dependence Tag Aggregator aggregates
                            tags produced by the Side Effect Tagger.
                        </p>
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                </sub_phase>
                <sub_phase>
                    <name>Field Read/Write Tag Aggregator</name>
                    <alias>tag.fieldrw</alias>
                    <short_desc>Field read/write aggregator</short_desc>
                    <long_desc>
                        The Field Read/Write Tag Aggregator aggregates field read/write
                        tags produced by the Field Read/Write Tagger, phase
                        <tt>jap.fieldrw</tt>.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>
                        <default>false</default>
                        <short_desc/>
                        <long_desc/>
                    </boolopt>
                </sub_phase>
            </phase>


            <phase>
                <name>Dava Body Creation</name>
                <alias>db</alias>
                <short_desc>Dummy phase to store options for Dava</short_desc>

                <long_desc>
                    The decompile (Dava) option is set using the -f dava options in Soot.
                    Options provided by Dava are added to this dummy phase so as not to clutter the soot general
                    arguments.
                    -p db (option name):(value) will be used to set all required values for Dava.
                </long_desc>
                <boolopt>
                    <name>Enabled</name>

                    <alias>enabled</alias>
                    <default>true</default>
                    <short_desc/>
                    <long_desc/>
                </boolopt>


                <boolopt>
                    <name>Source</name>

                    <alias>source-is-javac</alias>
                    <default>true</default>
                    <short_desc/>
                    <long_desc>
                        check out soot.dava.toolkits.base.misc.ThrowFinder
                        In short we want to ensure that if there are throw exception info in the class file dava uses
                        this info.
                    </long_desc>
                </boolopt>


                <sub_phase>
                    <name>Transformations</name>
                    <alias>db.transformations</alias>
                    <short_desc>The Dava back-end with all its transformations</short_desc>
                    <long_desc>
                        The transformations implemented using AST Traversal and structural flow analses on Dava's AST
                    </long_desc>


                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>

                        <default>true</default>
                    </boolopt>
                </sub_phase>

                <sub_phase>
                    <name>Renamer</name>
                    <alias>db.renamer</alias>
                    <short_desc>Apply heuristics based naming of local variables</short_desc>
                    <long_desc>If set, the renaming analyses implemented in Dava are applied to each method body being
                        decompiled. The analyses use heuristics to choose potentially better names for local variables.
                        (As of February 14th 2006, work is still under progress on these analyses
                        (dava.toolkits.base.renamer).
                    </long_desc>


                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>

                        <default>false</default>
                    </boolopt>
                </sub_phase>


                <sub_phase>
                    <name>De-obfuscate</name>
                    <alias>db.deobfuscate</alias>
                    <short_desc>Apply de-obfuscation analyses</short_desc>
                    <long_desc>Certain analyses make sense only when the bytecode is obfuscated code.
                        There are plans to implement such analyses and apply them on methods only if this flag is set.
                        Dead Code elimination which includes removing code guarded by some condition which is always
                        false or always true is one such
                        analysis. Another suggested analysis is giving default names to classes and fields. Onfuscators
                        love to use weird names
                        for fields and classes and even a simple re-naming of these could be a good help to the user.
                        Another more advanced analysis would be to check for redundant constant fields added by
                        obfuscators and then remove uses
                        of these constant fields from the code.
                    </long_desc>

                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>

                        <default>true</default>
                    </boolopt>

                </sub_phase>


                <sub_phase>

                    <name>Force Recompilability</name>
                    <alias>db.force-recompile</alias>

                    <short_desc>Try to get recompilable code.</short_desc>
                    <long_desc>While decompiling we have to be clear what our aim is: do we want to convert bytecode
                        to Java syntax and stay as close to the actual execution of bytecode or do we want recompilably
                        Java source representing
                        the bytecode. This distinction is important because some restrictions present in Java source are
                        absent from the bytecode.
                        Examples of this include that fact that in Java a call to a constructor or super needs to be the
                        first statement in
                        a constructors body. This restriction is absent from the bytecode. Similarly final fields HAVE
                        to be initialized
                        once and only once in either the static initializer (static fields) or all the constructors
                        (non-static fields). Additionally
                        the fields should be initialized on all possible execution paths. These restrictions are again
                        absent from the bytecode.
                        In doing a one-one conversion of bytecode to Java source then no attempt should be made to fix
                        any of these and similar problems
                        in the Java source. However, if the aim is to get recompilable code then these and similar
                        issues need to be fixed.
                        Setting the force-recompilability flag will ensure that the decompiler tries its best to produce
                        recompilable Java source.
                    </long_desc>
                    <boolopt>
                        <name>Enabled</name>
                        <alias>enabled</alias>

                        <default>true</default>
                    </boolopt>

                </sub_phase>

            </phase>


        </phaseopt>
        <macroopt>
            <name>Optimize</name>
            <alias>O</alias>
            <alias>optimize</alias>
            <expansion>-p</expansion>
            <expansion>gb.a1</expansion>
            <expansion>only-stack-locals:false</expansion>
            <expansion>-p</expansion>
            <expansion>gb.a2</expansion>
            <expansion>only-stack-locals:false</expansion>
            <expansion>-p</expansion>
            <expansion>bop</expansion>
            <expansion>enabled:true</expansion>
            <expansion>-p</expansion>
            <expansion>gop</expansion>
            <expansion>enabled:true</expansion>
            <expansion>-p</expansion>
            <expansion>jop</expansion>
            <expansion>enabled:true</expansion>
            <expansion>-p</expansion>
            <expansion>sop</expansion>
            <expansion>enabled:true</expansion>
            <short_desc>Perform intraprocedural optimizations</short_desc>
            <long_desc>
                Perform intraprocedural optimizations on the application classes.
            </long_desc>
        </macroopt>
        <macroopt>
            <name>Whole Program Optimize</name>
            <alias>W</alias>
            <alias>whole-optimize</alias>
            <expansion>-p</expansion>
            <expansion>wjop</expansion>
            <expansion>enabled:true</expansion>
            <expansion>-p</expansion>
            <expansion>wsop</expansion>
            <expansion>enabled:true</expansion>
            <expansion>-w</expansion>
            <expansion>-O</expansion>
            <short_desc>Perform whole program optimizations</short_desc>
            <long_desc>
                Perform whole program optimizations on the application
                classes. This enables the Whole-Jimple Optimization pack as well
                as whole program mode and intraprocedural optimizations.
            </long_desc>
        </macroopt>
        <boolopt>
            <name>Via Grimp</name>
            <alias>via-grimp</alias>
            <short_desc>Convert to bytecode via Grimp instead of via Baf</short_desc>
            <long_desc>
                Convert Jimple to bytecode via the Grimp intermediate
                representation instead of via the Baf intermediate
                representation.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Via Shimple</name>
            <alias>via-shimple</alias>
            <short_desc>Enable Shimple SSA representation</short_desc>
            <long_desc>
                Enable Shimple, Soot's SSA representation. This generates Shimple
                bodies for the application classes, optionally transforms them
                with analyses that run on SSA form, then turns them back into
                Jimple for processing by the rest of Soot. For more information,
                see the documentation for the <tt>shimp</tt>, <tt>stp</tt>, and
                <tt>sop</tt>
                phases.
            </long_desc>
        </boolopt>
        <multiopt>
            <name>Default ThrowAnalysis</name>
            <alias>throw-analysis</alias>
            <long_desc>
                This option specifies how to estimate the exceptions which each statement
                may throw when constructing exceptional CFGs.
            </long_desc>
            <value>
                <name>Pedantic</name>
                <alias>pedantic</alias>
                <short_desc>Pedantically conservative throw analysis</short_desc>
                <long_desc>
                    Says that any instruction may throw any
                    <code>Throwable</code>
                    whatsoever. Strictly speaking this is
                    correct, since the Java libraries include the
                    <code>Thread.stop(Throwable)</code>
                    method, which allows other threads to cause arbitrary exceptions
                    to occur at arbitrary points in the execution of a victim thread.
                </long_desc>
            </value>
            <value>
                <name>Unit</name>
                <alias>unit</alias>
                <short_desc>Unit Throw Analysis</short_desc>
                <default/>
                <long_desc>
                    Says that each statement in the intermediate representation
                    may throw those exception types associated with the corresponding
                    Java bytecode instructions in the JVM Specification. The
                    analysis deals with each statement in isolation, without regard
                    to the surrounding program.
                </long_desc>
            </value>
            <value>
                <name>Dalvik</name>
                <alias>dalvik</alias>
                <short_desc>Dalvik Throw Analysis</short_desc>
                <long_desc>
                    Specialized throw analysis implementation that covers the semantics of the Dalvik
                    IR used for Android apps
                </long_desc>
            </value>
        </multiopt>
        <multiopt>
            <name>Local Initialization ThrowAnalysis</name>
            <alias>check-init-ta</alias>
            <alias>check-init-throw-analysis</alias>
            <long_desc>
                This option specifies which throw analysis to use during local initialization
                checking inside soot.Body.
            </long_desc>
            <value>
                <name>Select Automatically</name>
                <alias>auto</alias>
                <default/>
                <short_desc>Automatically select a throw analysis</short_desc>
                <long_desc>
                    Selects the throw analysis to use for local initialization checking based on
                    information from other options. In particular, it will use 'dalvik' when
                    it detects it is analyzing an Android application (e.g. when --android-jars or
                    --force-android-jar are set) and 'pedantic' otherwise. This is the default.
                </long_desc>
            </value>
            <value>
                <name>Pedantic</name>
                <alias>pedantic</alias>
                <short_desc>Pedantically conservative throw analysis</short_desc>
                <long_desc>
                    Says that any instruction may throw any
                    <code>Throwable</code>
                    whatsoever. Strictly speaking this is
                    correct, since the Java libraries include the
                    <code>Thread.stop(Throwable)</code>
                    method, which allows other threads to cause arbitrary exceptions
                    to occur at arbitrary points in the execution of a victim thread.
                </long_desc>
            </value>
            <value>
                <name>Unit</name>
                <alias>unit</alias>
                <short_desc>Unit Throw Analysis</short_desc>
                <long_desc>
                    Says that each statement in the intermediate representation
                    may throw those exception types associated with the corresponding
                    Java bytecode instructions in the JVM Specification. The
                    analysis deals with each statement in isolation, without regard
                    to the surrounding program.
                </long_desc>
            </value>
            <value>
                <name>Dalvik</name>
                <alias>dalvik</alias>
                <short_desc>Dalvik Throw Analysis</short_desc>
                <long_desc>
                    Says that each statement in the intermediate representation
                    may throw those exception types associated with the corresponding
                    Java bytecode instructions in the Dalvik Specification. The
                    analysis deals with each statement in isolation, without regard
                    to the surrounding program. This is the equivalent of Unit above, but targeting
                    the Dalvik VM semantics as opposed to those of the JVM.
                </long_desc>
            </value>
        </multiopt>
        <boolopt>
            <name>Omit Excepting Unit Edges</name>
            <alias>omit-excepting-unit-edges</alias>
            <short_desc>Omit CFG edges to handlers from excepting units which lack side effects</short_desc>
            <long_desc>
                <p>
                    When constructing an <code>ExceptionalUnitGraph</code> or
                    <code>ExceptionalBlockGraph</code>, include edges to an exception
                    handler only from the predecessors of an instruction which may
                    throw an exception to the handler, and not from the excepting
                    instruction itself, unless the excepting instruction has
                    potential side effects.
                </p>

                <p>
                    Omitting edges from excepting units allows more accurate flow
                    analyses (since if an instruction without side effects throws an
                    exception, it has not changed the state of the computation). This
                    accuracy, though, could lead optimizations to generate
                    unverifiable code, since the dataflow analyses performed by
                    bytecode verifiers might include paths to exception handlers from
                    all protected instructions, regardless of whether the
                    instructions have side effects. (In practice, the pedantic throw
                    analysis suffices to pass verification in all VMs tested with
                    Soot to date, but the JVM specification does allow for less
                    discriminating verifiers which would reject some code that might
                    be generated using the pedantic throw analysis without also
                    adding edges from all excepting units.)
                </p>
            </long_desc>
        </boolopt>
        <macroopt>
            <name>Trim CFGs</name>
            <alias>trim-cfgs</alias>
            <expansion>-throw-analysis</expansion>
            <expansion>unit</expansion>
            <expansion>-omit-excepting-unit-edges</expansion>
            <expansion>-p</expansion>
            <expansion>jb.tt</expansion>
            <expansion>enabled:true</expansion>
            <short_desc>Trim unrealizable exceptional edges from CFGs</short_desc>
            <long_desc>
                <p>
                    When constructing CFGs which include exceptional edges, minimize
                    the number of edges leading to exception handlers by analyzing
                    which instructions might actually be executed before an exception
                    is thrown, instead of assuming that every instruction protected
                    by a handler has the potential to throw an exception the handler
                    catches.
                </p>
                <p>
                    <code>-trim-cfgs</code>
                    is shorthand for <code>-throw-analysis
                    unit -omit-excepting-unit-edges -p jb.tt enabled:true</code>.
                </p>
            </long_desc>
        </macroopt>
        <boolopt>
            <name>Ignore reolution errors</name>
            <alias>ire</alias>
            <alias>ignore-resolution-errors</alias>
            <default>false</default>
            <short_desc>Does not throw an exception when a program references an undeclared field or method.
            </short_desc>
            <long_desc>
                <p>
                    Some programs may contain dead code that references fields or methods that do not exist.
                    By default, Soot exists with an exception when this happens. If this option is enabled,
                    Soot only prints a warning but does not exit.
                </p>
            </long_desc>
        </boolopt>
    </section>
    <section>
        <name>Application Mode Options</name>
        <listopt>
            <name>Include Package</name>
            <alias>i</alias>
            <alias>include</alias>
            <set_arg_label>pkg</set_arg_label>
            <short_desc>Include classes in
                <use_arg_label/>
                as application classes
            </short_desc>
            <long_desc>
                <p>
                    Designate classes in packages whose names begin with
                    <use_arg_label/>
                    (e.g. <tt>java.util.</tt>) as application
                    classes which should be analyzed and output. This option allows
                    you to selectively analyze classes in some packages that Soot
                    normally treats as library classes.
                </p>
                <p>
                    You can use the include option multiple times, to designate
                    the classes of multiple packages as application classes.
                </p>
                <p>
                    If you specify both include and exclude options, first the
                    classes from all excluded packages are marked as library classes,
                    then the classes from all included packages are marked as
                    application classes.
                </p>
            </long_desc>
        </listopt>
        <listopt>
            <name>Exclude Package</name>
            <alias>x</alias>
            <alias>exclude</alias>
            <set_arg_label>pkg</set_arg_label>
            <short_desc>Exclude classes in
                <use_arg_label/>
                from application classes
            </short_desc>
            <long_desc>
                <p>
                    Excludes any classes in packages whose names begin with
                    <use_arg_label/>
                    from the set of application classes which are
                    analyzed and output, treating them as library classes instead.
                    This option allows you to selectively exclude classes
                    which would normally be treated as application classes
                </p>
                <p>
                    You can use the exclude option multiple times, to designate
                    the classes of multiple packages as library classes.
                </p>
                <p>
                    If you specify both include and exclude options, first the
                    classes from all excluded packages are marked as library classes,
                    then the classes from all included packages are marked as
                    application classes.
                </p>
            </long_desc>
        </listopt>
        <boolopt>
            <name>Include All Packages</name>
            <alias>include-all</alias>
            <short_desc>Set default excluded packages to empty list</short_desc>
            <long_desc>
                Soot uses a default list of packages (such as java.) which are deemed
                to contain library classes. This switch removes the default packages from the
                list of packages containing library classes.
                Individual packages can then be added using the exclude option.
            </long_desc>
        </boolopt>
        <listopt>
            <name>Dynamic Classes</name>
            <alias>dynamic-class</alias>
            <set_arg_label>class</set_arg_label>
            <short_desc>Note that
                <use_arg_label/>
                may be loaded dynamically
            </short_desc>
            <long_desc>
                <p>
                    Mark
                    <use_arg_label/>
                    as a class which the application may load
                    dynamically. Soot will read it as a library class even if it is
                    not referenced from the argument classes. This permits whole
                    program optimizations on programs which load classes dynamically
                    if the set of classes that can be loaded is known at compile
                    time.
                </p>
                <p>
                    You can use the dynamic class option multiple
                    times to specify more than one dynamic class.
                </p>
            </long_desc>
        </listopt>
        <listopt>
            <name>Dynamic Directories</name>
            <alias>dynamic-dir</alias>
            <set_arg_label>dir</set_arg_label>
            <short_desc>Mark all classes in
                <use_arg_label/>
                as potentially dynamic
            </short_desc>
            <long_desc>
                <p>Mark all class files in
                    <use_arg_label/>
                    as classes that may
                    be loaded dynamically. Soot will read them as library classes
                    even if they are not referenced from the argument classes.
                </p>
                <p>
                    You can specify more than one directory of potentially dynamic
                    classes by specifying multiple dynamic directory options.
                </p>
            </long_desc>
        </listopt>
        <listopt>
            <name>Dynamic Package</name>
            <alias>dynamic-package</alias>
            <set_arg_label>pkg</set_arg_label>
            <short_desc>Marks classes in
                <use_arg_label/>
                as potentially dynamic
            </short_desc>
            <long_desc>
                <p>
                    Marks all class files belonging to the package
                    <use_arg_label/>
                    or any of its subpackages as classes which the application may
                    load dynamically. Soot will read all classes in
                    <use_arg_label/>
                    as
                    library classes, even if they are not referenced by any of the
                    argument classes.
                </p>
                <p>To specify more than one dynamic package, use the dynamic
                    package option multiple times.
                </p>
            </long_desc>
        </listopt>
    </section>
    <section>
        <name>Input Attribute Options</name>
        <boolopt>
            <name>Keep Line Number</name>
            <alias>keep-line-number</alias>
            <default>false</default>
            <short_desc>Keep line number tables</short_desc>
            <long_desc>
                Preserve line number tables for class files throughout the
                transformations.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Keep Bytecode Offset</name>
            <alias>keep-bytecode-offset</alias>
            <alias>keep-offset</alias>
            <short_desc>Attach bytecode offset to IR</short_desc>
            <long_desc>Maintain bytecode offset tables for class files throughout the transformations.</long_desc>
        </boolopt>
    </section>

    <section>
        <name>Output Attribute Options</name>
        <boolopt>
            <name>Write Out Local Annotations</name>
            <alias>write-local-annotations</alias>
            <default>false</default>
            <short_desc>Write out debug annotations on local names</short_desc>
            <long_desc>
                Write out debug tables to indicate which register maps to which variable in the Jimple code.
            </long_desc>
        </boolopt>
    </section>

    <section>
        <name>Annotation Options</name>
        <macroopt>
            <name>Purity Annotation [AM]</name>
            <alias>annot-purity</alias>
            <expansion>-w</expansion>
            <expansion>-p</expansion>
            <expansion>cg.spark</expansion>
            <expansion>enabled:true</expansion>
            <expansion>-p</expansion>
            <expansion>wjap.purity</expansion>
            <expansion>enabled:true</expansion>
            <short_desc>Emit purity attributes</short_desc>
            <long_desc>
                Purity anaysis implemented by Antoine Mine and based on the paper
                A Combined Pointer and Purity Analysis Java Programs
                by Alexandru Salcianu and Martin Rinard.
            </long_desc>
        </macroopt>
        <macroopt>
            <name>Null Pointer Annotation</name>
            <alias>annot-nullpointer</alias>
            <expansion>-p</expansion>
            <expansion>jap.npc</expansion>
            <expansion>enabled:true</expansion>
            <expansion>-p</expansion>
            <expansion>tag.an</expansion>
            <expansion>enabled:true</expansion>
            <short_desc>Emit null pointer attributes</short_desc>
            <long_desc>
                Perform a static analysis of which dereferenced pointers may have
                null values, and annotate class files with attributes
                encoding the results of the analysis. For details, see the
                documentation for Null Pointer Annotation and for the
                Array Bounds and Null Pointer Check Tag Aggregator.
            </long_desc>
        </macroopt>
        <macroopt>
            <name>Array Bounds Annotation</name>
            <alias>annot-arraybounds</alias>
            <expansion>-p</expansion>
            <expansion>wjap.ra</expansion>
            <expansion>enabled:true</expansion>
            <expansion>-p</expansion>
            <expansion>jap.abc</expansion>
            <expansion>enabled:true</expansion>
            <expansion>-p</expansion>
            <expansion>tag.an</expansion>
            <expansion>enabled:true</expansion>
            <short_desc>Emit array bounds check attributes</short_desc>
            <long_desc>
                Perform a static analysis of which array bounds checks may safely
                be eliminated and annotate output class files with attributes
                encoding the results of the analysis. For details, see the
                documentation for Array Bounds Annotation and for the Array
                Bounds and Null Pointer Check Tag Aggregator.
            </long_desc>
        </macroopt>
        <macroopt>
            <name>Side effect annotation</name>
            <alias>annot-side-effect</alias>
            <expansion>-w</expansion>
            <expansion>-p</expansion>
            <expansion>jap.sea</expansion>
            <expansion>enabled:true</expansion>
            <expansion>-p</expansion>
            <expansion>tag.dep</expansion>
            <expansion>enabled:true</expansion>
            <short_desc>Emit side-effect attributes</short_desc>
            <long_desc>
                Enable the generation of side-effect attributes.
            </long_desc>
        </macroopt>
        <macroopt>
            <name>Field read/write annotation</name>
            <alias>annot-fieldrw</alias>
            <expansion>-w</expansion>
            <expansion>-p</expansion>
            <expansion>jap.fieldrw</expansion>
            <expansion>enabled:true</expansion>
            <expansion>-p</expansion>
            <expansion>tag.fieldrw</expansion>
            <expansion>enabled:true</expansion>
            <short_desc>Emit field read/write attributes</short_desc>
            <long_desc>Enable the generation of field read/write attributes.</long_desc>
        </macroopt>
    </section>
    <section>
        <name>Miscellaneous Options</name>
        <boolopt>
            <name>Time</name>
            <alias>time</alias>
            <short_desc>Report time required for transformations</short_desc>
            <long_desc>
                Report the time required to perform some of Soot's transformations.
            </long_desc>
        </boolopt>
        <boolopt>
            <name>Subtract Garbage Collection Time</name>
            <alias>subtract-gc</alias>
            <short_desc>Subtract gc from time</short_desc>
            <long_desc>
                Attempt to subtract time spent in garbage collection from
                the reports of times required for transformations.
            </long_desc>
        </boolopt>

        <boolopt>
            <name>No body releasing after writeout</name>
            <alias>no-writeout-body-releasing</alias>
            <short_desc>Disables the release of method bodies after writeout. This flag is used internally.</short_desc>
            <long_desc>
                By default soot releases the method bodies of all reachable classes after the final writeout. This
                option deactivates this behaviour. This flag should not affect end users at all.
            </long_desc>
        </boolopt>
    </section>
</options>
