package soot.javaToJimple.jj.parse;

import polyglot.ast.*;
import polyglot.lex.*;
import polyglot.util.*;
import polyglot.parse.*;
import polyglot.types.*;
import polyglot.*;
import soot.javaToJimple.jj.types.JjTypeSystem;
import soot.javaToJimple.jj.ast.JjNodeFactory;
import polyglot.ext.jl.parse.Name;
import soot.javaToJimple.jj.DPosition;
import java.util.*;
import polyglot.ast.Assert;

parser Grm extends polyglot.ext.jl.parse.Grm {:
    public final JjTypeSystem ts;
    public final JjNodeFactory nf;

    public Grm(Lexer l, TypeSystem t, NodeFactory n, ErrorQueue q) {
        super(l, t, n, q);
        ts = (JjTypeSystem) t;
        nf = (JjNodeFactory) n;
    }

    public static Position pos(Object first, Object last){
      
        //System.out.println("first: "+first+" class: "+first.getClass()+" last: "+last+" class: "+last.getClass());
        Position fpos = null;
        Position epos = null;
        if (first instanceof Node) {
            fpos = pos ((Node) first);
        }
        else if (first instanceof Token) {
            fpos = pos ((Token) first);
        }
        else if (first instanceof Type) {
            fpos = pos ((Type) first);
        }
        else if (first instanceof List) {
            fpos = pos ((List) first);
        }
        else if (first instanceof Name) {
            fpos = pos ((Name) first);
        }
        else if (first instanceof VarDeclarator) {
            fpos = pos ((VarDeclarator) first);
        }
        else {
            //System.out.println(first.getClass());
        }
        
        if (last instanceof Node) {
            epos = pos ((Node) last);
        }
        else if (last instanceof Token) {
            epos = pos ((Token) last);
        }
        else if (last instanceof Type) {
            epos = pos ((Type) last);
        }
        else if (last instanceof List) {
            epos = pos ((List) last);
        }
        else if (last instanceof Name) {
            epos = pos ((Name) last);
        }
        else if (last instanceof VarDeclarator) {
            epos = pos ((VarDeclarator) last);
        }
        else {
            //System.out.println(last.getClass());
        }

            
        DPosition real_pos = null;
        
        if ((fpos != null) && (epos != null)) {
            DPosition dpos = (DPosition)epos;
        
            real_pos = new DPosition(fpos.file(), fpos.line(), fpos.column(), dpos.endCol(), dpos.endLine());

        }
        return real_pos;

    }
    
    public static Position pos(List l){

        if (l == null | l.isEmpty()){
            return null;
        }
        
        Object first = l.get (0);
        Object last = l.get (l.size()-1);

        return pos(first, last);
    }
  
  public List variableDeclarators(TypeNode a, List b, Flags flags)
    throws Exception
  {
    List l = new TypedList(new LinkedList(), LocalDecl.class, false);
    for (Iterator i = b.iterator(); i.hasNext(); ) {
	VarDeclarator d = (VarDeclarator) i.next();
	l.add(nf.LocalDecl(pos(a, d), flags, array(a, d.dims),
				  d.name, d.init));
    }
    return l;
  }
:};

scan with {: return nextSymbol(); :};

terminal Token BOOLEAN; // primitive_type
terminal Token BYTE, SHORT, INT, LONG, CHAR; // integral_type
terminal Token FLOAT, DOUBLE; // floating_point_type
terminal Token LBRACK, RBRACK; // array_type
terminal Identifier IDENTIFIER; // name
terminal Token DOT; // qualified_name
terminal Token SEMICOLON, MULT, COMMA, LBRACE, RBRACE, EQ; // separators
terminal Token LPAREN, RPAREN, COLON; // more separators
terminal Token PACKAGE; // package_declaration
terminal Token IMPORT; // import_declaration
terminal Token PUBLIC, PROTECTED, PRIVATE; // modifier
terminal Token STATIC; // modifier
terminal Token ABSTRACT, FINAL, NATIVE, SYNCHRONIZED, TRANSIENT, VOLATILE;
terminal Token CLASS; // class_declaration
terminal Token EXTENDS; // super
terminal Token IMPLEMENTS; // interfaces
terminal Token VOID; // method_header
terminal Token THROWS; // throws
terminal Token THIS, SUPER; // explicit_constructor_invocation
terminal Token INTERFACE; // interface_declaration
terminal Token IF, ELSE; // if_then_statement, if_then_else_statement
terminal Token SWITCH; // switch_statement
terminal Token CASE, DEFAULT; // switch_label
terminal Token DO, WHILE; // while_statement, do_statement
terminal Token FOR; // for_statement
terminal Token BREAK; // break_statement
terminal Token CONTINUE; // continue_statement
terminal Token RETURN; // return_statement
terminal Token THROW; // throw_statement
terminal Token TRY; // try_statement
terminal Token CATCH; // catch_clause
terminal Token FINALLY; // finally
terminal Token NEW; // class_instance_creation_expression
terminal Token PLUSPLUS; // postincrement_expression
terminal Token MINUSMINUS; // postdecrement_expression
terminal Token PLUS, MINUS, COMP, NOT, DIV, MOD;
terminal Token LSHIFT, RSHIFT, URSHIFT; // shift_expression
terminal Token LT, GT, LTEQ, GTEQ, INSTANCEOF; // relational_expression
terminal Token EQEQ, NOTEQ; // equality_expression
terminal Token AND; // and_expression
terminal Token XOR; // exclusive_or_expression
terminal Token OR;  // inclusive_or_expression
terminal Token ANDAND; // conditional_and_expression
terminal Token OROR; // conditional_or_expression
terminal Token QUESTION; // conditional_expression
terminal Token MULTEQ, DIVEQ, MODEQ, PLUSEQ, MINUSEQ; // assignment_operator
terminal Token LSHIFTEQ, RSHIFTEQ, URSHIFTEQ; // assignment_operator
terminal Token ANDEQ, XOREQ, OREQ; // assignment_operator

terminal polyglot.lex.IntegerLiteral INTEGER_LITERAL;
terminal polyglot.lex.LongLiteral LONG_LITERAL;
terminal polyglot.lex.DoubleLiteral DOUBLE_LITERAL;
terminal polyglot.lex.FloatLiteral FLOAT_LITERAL;
terminal polyglot.lex.BooleanLiteral BOOLEAN_LITERAL;
terminal polyglot.lex.CharacterLiteral CHARACTER_LITERAL;
terminal polyglot.lex.StringLiteral STRING_LITERAL;
terminal polyglot.lex.NullLiteral NULL_LITERAL;

// strictfp keyword, new in Java 1.2
terminal Token STRICTFP;

// assert keyword, new in Java 1.4
terminal Token ASSERT;

// Reserved but unused:
terminal CONST, GOTO;

// 19.2) The Syntactic Grammar
non terminal SourceFile goal;
// 19.3) Lexical Structure
non terminal polyglot.ast.Lit literal;
// 19.4) Types, Values, and Variables
non terminal TypeNode type, primitive_type, numeric_type;
non terminal TypeNode integral_type, floating_point_type;
non terminal TypeNode reference_type;
non terminal TypeNode class_or_interface_type;
non terminal TypeNode class_type, interface_type;
non terminal TypeNode array_type;
// 19.5) Names
non terminal Name name, simple_name, qualified_name;
// 19.6) Packages
non terminal SourceFile compilation_unit;
non terminal PackageNode package_declaration_opt, package_declaration;
non terminal List import_declarations_opt, import_declarations;
non terminal List type_declarations_opt, type_declarations;
non terminal Import import_declaration;
non terminal Import single_type_import_declaration;
non terminal Import type_import_on_demand_declaration;
non terminal ClassDecl type_declaration;
// 19.7) Productions used only in the LALR(1) grammar
non terminal Flags modifiers_opt, modifiers, modifier;
// 19.8.1) Class Declaration
non terminal ClassDecl class_declaration;
non terminal TypeNode super, super_opt;
non terminal List interfaces, interfaces_opt, interface_type_list;
non terminal ClassBody class_body;
non terminal List class_body_declarations, class_body_declarations_opt;
non terminal List class_body_declaration, class_member_declaration;
// 19.8.2) Field Declarations
non terminal List field_declaration;
non terminal List variable_declarators;
non terminal VarDeclarator variable_declarator;
non terminal VarDeclarator variable_declarator_id;
non terminal Expr variable_initializer;
// 19.8.3) Method Declarations
non terminal MethodDecl method_declaration, method_header;
non terminal List formal_parameter_list_opt, formal_parameter_list;
non terminal Formal formal_parameter;
non terminal List throws_opt, throws;
non terminal List class_type_list;
non terminal Block method_body;
// 19.8.4) Static Initializers
non terminal Block static_initializer;
// 19.8.5) Constructor Declarations
non terminal ConstructorDecl constructor_declaration;
non terminal Block constructor_body;
non terminal ConstructorCall explicit_constructor_invocation;
// 19.9.1) Interface Declarations
non terminal ClassDecl interface_declaration;
non terminal List extends_interfaces_opt, extends_interfaces;
non terminal ClassBody interface_body;
non terminal List interface_member_declarations_opt, interface_member_declarations;
non terminal List interface_member_declaration;
non terminal List constant_declaration;
non terminal MethodDecl abstract_method_declaration;
// 19.10) Arrays
non terminal ArrayInit array_initializer;
non terminal List variable_initializers;
// 19.11) Blocks and Statements
non terminal Block block;
non terminal List block_statements_opt, block_statements;
non terminal List block_statement;
non terminal List local_variable_declaration_statement;
non terminal List local_variable_declaration;
non terminal Stmt statement, statement_no_short_if;
non terminal Stmt statement_without_trailing_substatement;
non terminal Empty empty_statement;
non terminal Labeled labeled_statement, labeled_statement_no_short_if;
non terminal Stmt expression_statement;
non terminal Expr statement_expression;
non terminal If if_then_statement;
non terminal If if_then_else_statement, if_then_else_statement_no_short_if;
non terminal Switch switch_statement;
non terminal List switch_block, switch_block_statement_groups;
non terminal List switch_block_statement_group, switch_labels;
non terminal Case switch_label;
non terminal While while_statement, while_statement_no_short_if;
non terminal Do do_statement;
non terminal For for_statement, for_statement_no_short_if;
non terminal List for_init_opt, for_init;
non terminal List for_update_opt, for_update;
non terminal List statement_expression_list;
non terminal Name identifier_opt;
non terminal Branch break_statement, continue_statement;
non terminal Return return_statement;
non terminal Throw throw_statement;
non terminal Synchronized synchronized_statement;
non terminal Try try_statement;
non terminal List catches_opt, catches;
non terminal Catch catch_clause;
non terminal Block finally;
non terminal Assert assert_statement;
// 19.12) Expressions
non terminal Expr primary, primary_no_new_array;
non terminal Expr class_instance_creation_expression;
non terminal List argument_list_opt, argument_list;
non terminal NewArray array_creation_expression;
non terminal List dim_exprs;
non terminal Expr dim_expr;
non terminal Integer dims_opt, dims;
non terminal Field field_access;
non terminal Call method_invocation;
non terminal ArrayAccess array_access;
non terminal Expr postfix_expression;
non terminal Unary postincrement_expression, postdecrement_expression;
non terminal Expr unary_expression, unary_expression_not_plus_minus;
non terminal Unary preincrement_expression, predecrement_expression;
non terminal Cast cast_expression;
non terminal Expr multiplicative_expression, additive_expression;
non terminal Expr shift_expression, relational_expression, equality_expression;
non terminal Expr and_expression, exclusive_or_expression, inclusive_or_expression;
non terminal Expr conditional_and_expression, conditional_or_expression;
non terminal Expr conditional_expression, assignment_expression;
non terminal Expr assignment;
non terminal Expr left_hand_side;
non terminal Assign.Operator assignment_operator;
non terminal Expr expression_opt, expression;
non terminal Expr constant_expression;

start with goal;

// 19.2) The Syntactic Grammar
goal ::=    
                    // SourceFile
        compilation_unit:a
            {: RESULT = a; :}
    ;

// 19.3) Lexical Structure.
literal ::=
                    // Lit
        INTEGER_LITERAL:a    
            {: RESULT = parser.nf.IntLit(parser.pos(a), IntLit.INT,
                                     a.getValue().intValue()); :} 
    |   LONG_LITERAL:a    
            {: RESULT = parser.nf.IntLit(parser.pos(a), IntLit.LONG,
                     a.getValue().longValue()); :} 
    |   DOUBLE_LITERAL:a
            {: RESULT = parser.nf.FloatLit(parser.pos(a), FloatLit.DOUBLE,
                                           a.getValue().doubleValue()); :}
    |   FLOAT_LITERAL:a
            {: RESULT = parser.nf.FloatLit(parser.pos(a), FloatLit.FLOAT,
                                           a.getValue().floatValue()); :}
    |   BOOLEAN_LITERAL:a
            {: RESULT = parser.nf.BooleanLit(parser.pos(a),
                                         a.getValue().booleanValue()); :}
    |   CHARACTER_LITERAL:a
            {: RESULT = parser.nf.CharLit(parser.pos(a),
                      a.getValue().charValue()); :}
    |   STRING_LITERAL:a
            {: RESULT = parser.nf.StringLit(parser.pos(a), a.getValue()); :}
    |   NULL_LITERAL:a
            {: RESULT = parser.nf.NullLit(parser.pos(a)); :}
    ;

// 19.4) Types, Values, and Variables
type ::=
                    // TypeNode
        primitive_type:a
            {: RESULT = a; :}
    |   reference_type:a
            {: RESULT = a; :}
    ;
primitive_type ::=
                    // TypeNode
        numeric_type:a
            {: RESULT = a; :}
    |   BOOLEAN:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Boolean()); :}
    ;
numeric_type::=
                    // TypeNode
        integral_type:a
            {: RESULT = a; :}
    |   floating_point_type:a
            {: RESULT = a; :}
    ;
integral_type ::=
                    // TypeNode
        BYTE:a 
            {: RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Byte()); :}
    |   CHAR:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Char()); :}
    |   SHORT:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Short()); :}
    |   INT:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Int()); :}
    |   LONG:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Long()); :}
    ;
floating_point_type ::=
                    // TypeNode
        FLOAT:a 
            {: RESULT = parser.nf.CanonicalTypeNode(parser.pos(a),
                       parser.ts.Float()); :}
    |   DOUBLE:a
            {: RESULT = parser.nf.CanonicalTypeNode(parser.pos(a),
                       parser.ts.Double()); :}
    ;
reference_type ::=
                    // TypeNode
        class_or_interface_type:a
            {: RESULT = a; :}
    |   array_type:a
            {: RESULT = a; :}
    ;
class_or_interface_type ::=
                    // TypeNode
        name:a
            {: RESULT = a.toType(); :}
    ;
class_type ::=
                    // TypeNode
        class_or_interface_type:a
            {: RESULT = a; :}
    ;
interface_type ::=
                    // TypeNode
        class_or_interface_type:a
            {: RESULT = a; :}
    ;
array_type ::=
                    // TypeNode
        primitive_type:a dims:b
            {: RESULT = parser.array(a, b.intValue()); :}
    |   name:a dims:b
            {: RESULT = parser.array(a.toType(), b.intValue()); :}
    ;
// 19.5) Names
name    ::=
                    // Name
        simple_name:a
            {: RESULT = a; :}
    |   qualified_name:a
            {: RESULT = a; :}
    ;
simple_name ::=
                    // Name
        IDENTIFIER:a
            {: RESULT = new Name(parser, parser.pos(a), a.getIdentifier()); :}
    ;
qualified_name ::=
                    // Name
        name:a DOT IDENTIFIER:b
            {: RESULT = new Name(parser, parser.pos(a, b), a, b.getIdentifier()); :}
    ;
// 19.6) Packages
compilation_unit ::=
                    // SourceFile
        package_declaration_opt:a
        import_declarations_opt:b
        type_declarations_opt:c
            {: RESULT = parser.nf.SourceFile(new Position(parser.lexer.file()),
					     a, b, c);
	    :}
        ;
package_declaration_opt ::=
                    // PackageNode
        package_declaration:a
            {: RESULT = a; :}
    |
            {: RESULT = null; :}
    ;
import_declarations_opt ::=
                    // List of Import
        import_declarations:a 
            {: RESULT = a; :} 
    |
            {: RESULT = new TypedList(new LinkedList(), Import.class, false); :}
    ;
type_declarations_opt   ::=
                    // List of ClassDecl
        type_declarations:a 
            {: RESULT = a; :} 
    |   
            {: RESULT = new TypedList(new LinkedList(), ClassDecl.class, false); :}
    ;
import_declarations ::=
                    // List of Import
        import_declaration:a
            {: List l = new TypedList(new LinkedList(), Import.class, false); 
               l.add(a);
               RESULT = l; :}
    |   import_declarations:a import_declaration:b
            {: RESULT = a; 
               a.add(b); :}
    ;
type_declarations ::=
                    // List of ClassDecl
        type_declaration:a
            {: List l = new TypedList(new LinkedList(), ClassDecl.class, false); 
               if (a != null)
                   l.add(a);
               RESULT = l; :}
    |   type_declarations:a type_declaration:b
            {: RESULT = a;
               if (b != null)
                   a.add(b); :}
    ;
package_declaration ::=
                    // PackageNode
        PACKAGE name:a SEMICOLON
            {: RESULT = a.toPackage(); :}
    ;
import_declaration ::=
                    // Import
        single_type_import_declaration:a
            {: RESULT = a; :}
    |   type_import_on_demand_declaration:a
            {: RESULT = a; :}
    ;
single_type_import_declaration ::=
                    // Import
        IMPORT:a name:b SEMICOLON:c
            {: RESULT = parser.nf.Import(parser.pos(a, c), Import.CLASS, b.toString()); :}
    ;
type_import_on_demand_declaration ::=
                    // Import
        IMPORT:a name:b DOT MULT SEMICOLON:c
            {: RESULT = parser.nf.Import(parser.pos(a, c), Import.PACKAGE, b.toString()); :}
    ;
type_declaration ::=
                    // ClassDecl
        class_declaration:a
            {: RESULT = a; :}
    |   interface_declaration:a
            {: RESULT = a; :}    
    |   SEMICOLON
            {: RESULT = null; :}
    ;

// 19.7) Productions used only in the LALR(1) grammar
modifiers_opt::=
                    // Flags
            {: RESULT = Flags.NONE; :}
    |   modifiers:a
            {: RESULT = a; :}
    ;
modifiers ::=
                    // Flags
        modifier:a 
            {: RESULT = a; :}
    |   modifiers:a modifier:b
            {: if (a .intersects(b)) parser.die(parser.position());    
                 RESULT = a.set(b); :}
    ;
modifier ::=
                    // Flags
        PUBLIC:a
            {: RESULT = Flags.PUBLIC; :}
    |   PROTECTED:a 
            {: RESULT = Flags.PROTECTED; :}
    |   PRIVATE:a
            {: RESULT = Flags.PRIVATE; :}
    |   STATIC:a
            {: RESULT = Flags.STATIC; :}
    |   ABSTRACT:a 
            {: RESULT = Flags.ABSTRACT; :}
    |   FINAL:a 
            {: RESULT = Flags.FINAL; :}
    |   NATIVE:a 
            {: RESULT = Flags.NATIVE; :}
    |   SYNCHRONIZED:a
            {: RESULT = Flags.SYNCHRONIZED; :}
    |   TRANSIENT:a 
            {: RESULT = Flags.TRANSIENT; :}
    |   VOLATILE:a
            {: RESULT = Flags.VOLATILE; :}
    |   STRICTFP:a
            {: RESULT = Flags.STRICTFP; :}
    ;
// 19.8) Classes

// 19.8.1) Class Declarations
class_declaration ::=
                    // ClassDecl
        modifiers_opt:a CLASS:n IDENTIFIER:b 
                super_opt:c interfaces_opt:d class_body:e
            {: RESULT = parser.nf.ClassDecl(parser.pos(n, e),
                a, b.getIdentifier(), c, d, e); :}
    ;
super ::=
                    // TypeNode
        EXTENDS class_type:a 
            {: RESULT = a; :}        
    ;
super_opt ::=
                    // TypeNode
    |   super:a
            {: RESULT = a; :}
    ;
interfaces ::=
                    // List of TypeNode
        IMPLEMENTS interface_type_list:a
            {: RESULT = a; :}
    ;
interfaces_opt::=
                    // List of TypeNode
            {: RESULT = new TypedList(new LinkedList(), TypeNode.class, false); :}
    |   interfaces:a
            {: RESULT = a; :} 
    ;
interface_type_list ::=
                    // List of TypeNode
        interface_type:a 
            {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
               l.add(a);
               RESULT = l; :}
    |   interface_type_list:a COMMA interface_type:b
            {: RESULT = a;
               a.add(b); :}
    ;
class_body ::=
                    // ClassBody
        LBRACE:n class_body_declarations_opt:a RBRACE:b 
            {: RESULT = parser.nf.ClassBody(parser.pos(n, b), a); :}
    ;
class_body_declarations_opt ::=
                    // List of ClassMember
            {: RESULT = new TypedList(new LinkedList(), ClassMember.class, false); :}
    |   class_body_declarations:a
            {: RESULT = a; :}
    ;
class_body_declarations ::=
                    // List of ClassMember
        class_body_declaration:a
            {: RESULT = a; :}
    |   class_body_declarations:a class_body_declaration:b
            {: RESULT = a;
               a.addAll(b); :}
    ;
class_body_declaration ::=
                    // List of ClassMember
        class_member_declaration:a
            {: RESULT = a; :}
    |   static_initializer:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(parser.nf.Initializer(parser.pos(a), Flags.STATIC, a));
               RESULT = l; :}
    |   constructor_declaration:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; :}
    |   block:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(parser.nf.Initializer(parser.pos(a), Flags.NONE, a));
               RESULT = l; :}
    |   SEMICOLON
            {: RESULT = Collections.EMPTY_LIST; :}
    ;
class_member_declaration ::=
                    // List of ClassMember
        field_declaration:a
            {: RESULT = a; :}
    |   method_declaration:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; :}
        /* repeat the prod for 'class_declaration' here: */
    |   modifiers_opt:a CLASS:n IDENTIFIER:b
                    super_opt:c interfaces_opt:d class_body:e
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(parser.nf.ClassDecl(parser.pos(n, e),
                        a, b.getIdentifier(), c, d, e));
               RESULT = l; :}
    |   interface_declaration:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; :}
    ;

// 19.8.2) Field Declarations
field_declaration ::=
                    // List of ClassMember
        modifiers_opt:a type:b variable_declarators:c SEMICOLON:e
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               for (Iterator i = c.iterator(); i.hasNext(); ) {
                   VarDeclarator d = (VarDeclarator) i.next();
                   l.add(parser.nf.FieldDecl(parser.pos(b, e),
                                             a, parser.array(b, d.dims),
                                             d.name, d.init));
               }
               RESULT = l; :}
    ;
variable_declarators ::=
                    // List of VarDeclarator
        variable_declarator:a
            {: List l = new TypedList(new LinkedList(), VarDeclarator.class, false);
               l.add(a);
               RESULT = l; :}
    |   variable_declarators:a COMMA variable_declarator:b
            {: RESULT = a;
               a.add(b); :}
    ;
variable_declarator ::=
                // VarDeclarator
        variable_declarator_id:a
            {: RESULT = a; :}
    |   variable_declarator_id:a EQ variable_initializer:b
            {: RESULT = a;
               a.init = b; :}
    ;
variable_declarator_id ::=
                // VarDeclarator
        IDENTIFIER:a
            {: RESULT = new VarDeclarator(parser.pos(a),
                            a.getIdentifier()); :}
    |   variable_declarator_id:a LBRACK RBRACK
            {: RESULT = a;
               a.dims++; :}
    ;
variable_initializer ::=
                    // Expr
        expression:a
            {: RESULT = a; :}
    |   array_initializer:a
            {: RESULT = a; :}
    ;

// 19.8.3) Method Declarations
method_declaration ::=
                    // MethodDecl
        method_header:a method_body:b
            {: RESULT = (MethodDecl) a.body(b); :}
    ;
method_header ::=
                    // MethodDecl
        modifiers_opt:a type:b IDENTIFIER:c LPAREN 
                formal_parameter_list_opt:d RPAREN:g dims_opt:e throws_opt:f
            {: RESULT = parser.nf.MethodDecl(parser.pos(b, g), a,
                parser.array(b, e.intValue()), c.getIdentifier(),
                d, f, null); :}
    |   modifiers_opt:a VOID:b IDENTIFIER:c LPAREN
                formal_parameter_list_opt:d RPAREN:g throws_opt:f
            {: RESULT = parser.nf.MethodDecl(parser.pos(b, g), a,
                parser.nf.CanonicalTypeNode(parser.pos(b),
                parser.ts.Void()), c.getIdentifier(), d, f, null); :}
    ;
formal_parameter_list_opt ::=        
                    // List of Formal
            {: RESULT = new TypedList(new LinkedList(), Formal.class, false); :} 
    |   formal_parameter_list:a
            {: RESULT = a; :}
    ;
formal_parameter_list ::=
                    // List of Formal
        formal_parameter:a
            {: List l = new TypedList(new LinkedList(), Formal.class, false);
               l.add(a);
               RESULT = l; :}
    |   formal_parameter_list:a COMMA formal_parameter:b
            {: RESULT = a;
               a.add(b); :}    
    ;
formal_parameter ::=
                    // Formal
        type:a variable_declarator_id:b
            {: RESULT = parser.nf.Formal(parser.pos(a, b), Flags.NONE,
                                         parser.array(a, b.dims), b.name); :}
    |   FINAL:f type:a variable_declarator_id:b
            {: RESULT = parser.nf.Formal(parser.pos(a, b), Flags.FINAL,
                     parser.array(a, b.dims), b.name); :}
    ;
throws_opt ::=                
                    // List of TypeNode
            {: RESULT = new TypedList(new LinkedList(), TypeNode.class, false); :}
    |   throws:a
            {: RESULT = a; :}
    ;
throws ::=                
                    // List of TypeNode
        THROWS class_type_list:a
            {: RESULT = a; :}
    ;
class_type_list ::=
                    // List of TypeNode
        class_type:a
            {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
               l.add(a);
               RESULT = l; :}
    |   class_type_list:a COMMA class_type:b
            {: RESULT = a;
               a.add(b); :}    
    ;
method_body ::=
                    // Block
        block:a
            {: RESULT = a; :}
    |   SEMICOLON
            {: RESULT = null; :}
    ;

// 19.8.4) Static Initializers
static_initializer ::=
                    // Block
        STATIC block:a
            {: RESULT = a; :}
    ;

// 19.8.5) Constructor Declarations
constructor_declaration ::=
                    // ConstructorDecl
        modifiers_opt:m simple_name:a LPAREN formal_parameter_list_opt:b RPAREN
            throws_opt:c constructor_body:d
            {: RESULT = parser.nf.ConstructorDecl(parser.pos(a, d), m, a.toString(), b,
                c, d); :}
    ;
constructor_body ::=
                    // Block
        LBRACE:n explicit_constructor_invocation:a block_statements:b RBRACE:d
            {: List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.add(a);
               l.addAll(b);
               RESULT = parser.nf.Block(parser.pos(n, d), l); :}
    |   LBRACE:n explicit_constructor_invocation:a RBRACE:d
            {: RESULT = parser.nf.Block(parser.pos(n, d), a); :}
    |   LBRACE:n block_statements:a RBRACE:d
            {: a.add(0, parser.nf.SuperCall(parser.pos(n, d), 
                Collections.EMPTY_LIST));
               RESULT = parser.nf.Block(parser.pos(n, d), a); :}
    |   LBRACE:n RBRACE:d
            {: RESULT = parser.nf.Block(parser.pos(n, d),
                parser.nf.SuperCall(parser.pos(n, d),
                Collections.EMPTY_LIST)); :}
    ;
explicit_constructor_invocation ::=
                    // ConstructorCall
        THIS:a LPAREN argument_list_opt:b RPAREN SEMICOLON:c
            {: RESULT = parser.nf.ThisCall(parser.pos(a, c), b); :}
    |   SUPER:a LPAREN argument_list_opt:b RPAREN SEMICOLON:c
            {: RESULT = parser.nf.SuperCall(parser.pos(a, c), b); :}
    |   primary:a DOT THIS:n LPAREN argument_list_opt:b RPAREN SEMICOLON:c
            {: RESULT = parser.nf.ThisCall(parser.pos(a, c), a, b); :}
    |   primary:a DOT SUPER:n LPAREN argument_list_opt:b RPAREN SEMICOLON:c
            {: RESULT = parser.nf.SuperCall(parser.pos(a, c), a, b); :}
    ;

// 19.9) Interfaces

// 19.9.1) Interface Declarations
interface_declaration ::=
                    // ClassDecl
        modifiers_opt:a INTERFACE:n IDENTIFIER:b
                extends_interfaces_opt:c interface_body:d
            {: RESULT = parser.nf.ClassDecl(
                    parser.pos(n, d), a.Interface(),
                        b.getIdentifier(), null, c, d); :}
    ;
extends_interfaces_opt ::=
                    // List of TypeNode
            {: RESULT = new TypedList(new LinkedList(), TypeNode.class, false); :}
    |   extends_interfaces:a
            {: RESULT = a; :}
    ;
extends_interfaces ::=
                    // List of TypeNode
        EXTENDS interface_type:a
            {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
               l.add(a);
               RESULT = l; :}
    |   extends_interfaces:a COMMA interface_type:b
            {: RESULT = a;
               a.add(b); :}    
    ;
interface_body ::=
                    // ClassBody
        LBRACE:n interface_member_declarations_opt:a RBRACE:d
            {: RESULT = parser.nf.ClassBody(parser.pos(n, d), a); :}
    ;
interface_member_declarations_opt ::=
                    // List of ClassMember
            {: RESULT = new TypedList(new LinkedList(), ClassMember.class, false); :}
    |   interface_member_declarations:a
            {: RESULT = a; :}
    ;
interface_member_declarations ::=
                    // List of ClassMember
        interface_member_declaration:a
            {: RESULT = a; :}        
    |   interface_member_declarations:a interface_member_declaration:b
            {: RESULT = a;
               a.addAll(b); :}
    ;
interface_member_declaration ::=
                    // List of ClassMember
        constant_declaration:a
            {: RESULT = a; :}
    |   abstract_method_declaration:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; :}
    |   class_declaration:a 
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; :}
    |   interface_declaration:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; :}
    |   SEMICOLON
            {: RESULT = Collections.EMPTY_LIST; :}
    ;
constant_declaration ::=
                    // List of ClassMember
        field_declaration:a
            {: RESULT = a; :}
    ;
abstract_method_declaration ::=
                    // MethodDecl
        method_header:a SEMICOLON
            {: RESULT = a; :}
    ;

// 19.10) Arrays
array_initializer ::=
                    // ArrayInit
        LBRACE:n variable_initializers:a COMMA RBRACE:d
            {: RESULT = parser.nf.ArrayInit(parser.pos(n, d), a); :}
    |   LBRACE:n variable_initializers:a RBRACE:d
            {: RESULT = parser.nf.ArrayInit(parser.pos(n, d), a); :}
    |   LBRACE:n COMMA RBRACE:d
            {: RESULT = parser.nf.ArrayInit(parser.pos(n, d)); :}
    |   LBRACE:n RBRACE:d
            {: RESULT = parser.nf.ArrayInit(parser.pos(n, d)); :}
    ;
variable_initializers ::=
                    // List of Expr
        variable_initializer:a
            {: List l = new TypedList(new LinkedList(), Expr.class, false);
           l.add(a);
           RESULT = l; :}
    |   variable_initializers:a COMMA variable_initializer:b
            {: RESULT = a; a.add(b); :}    
    ;

// 19.11) Blocks and Statements
block ::=
                    // Block
        LBRACE:n block_statements_opt:a RBRACE:d
            {: RESULT = parser.nf.Block(parser.pos(n, d), a); :}
    ;
block_statements_opt ::=
                    // List of Stmt
            {: RESULT = new TypedList(new LinkedList(), Stmt.class, false); :}
    |   block_statements:a
            {: RESULT = a; :}
    ;
block_statements ::=
                    // List of Stmt
        block_statement:a
            {: List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.addAll(a);
               RESULT = l; :}
    |   block_statements:a block_statement:b
            {: RESULT = a;
               a.addAll(b); :}
    ;
block_statement ::=
                    // List of Stmt
        local_variable_declaration_statement:a
            {: RESULT = a; :}
    |   statement:a
            {: List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.add(a);
               RESULT = l; :}
    |   class_declaration:a
            {: List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.add(parser.nf.LocalClassDecl(parser.pos(a), a));
               RESULT = l; :}
    |   interface_declaration:a
            {: List l = new TypedList(new LinkedList(), Stmt.class, false);
               l.add(parser.nf.LocalClassDecl(parser.pos(a), a));
               RESULT = l; :}
    ;
local_variable_declaration_statement ::=
                    // List of LocalDecl
        local_variable_declaration:a SEMICOLON
            {: RESULT = a; :}
    ;
local_variable_declaration ::=
                    // List of LocalDecl
        type:a variable_declarators:b
            {: RESULT = parser.variableDeclarators(a, b, Flags.NONE); :}
    |   FINAL type:a variable_declarators:b
            {: RESULT = parser.variableDeclarators(a, b, Flags.FINAL); :}
    ;
statement ::=
                    // Stmt
        statement_without_trailing_substatement:a
            {: RESULT = a; :}
    |   labeled_statement:a
            {: RESULT = a; :}
    |   if_then_statement:a
            {: RESULT = a; :}
    |   if_then_else_statement:a
            {: RESULT = a; :}
    |   while_statement:a
            {: RESULT = a; :}
    |   for_statement:a
            {: RESULT = a; :}
    ;
statement_no_short_if ::=
                    // Stmt
        statement_without_trailing_substatement:a
            {: RESULT = a; :}
    |   labeled_statement_no_short_if:a
            {: RESULT = a; :}
    |   if_then_else_statement_no_short_if:a
            {: RESULT = a; :}
    |   while_statement_no_short_if:a
            {: RESULT = a; :}
    |   for_statement_no_short_if:a
            {: RESULT = a; :}
    ;
statement_without_trailing_substatement ::=
                    // Stmt 
        block:a
            {: RESULT = a; :}
    |   empty_statement:a
            {: RESULT = a; :}
    |   expression_statement:a
            {: RESULT = a; :}
    |   switch_statement:a
            {: RESULT = a; :}
    |   do_statement:a
            {: RESULT = a; :}
    |   break_statement:a
            {: RESULT = a; :}
    |   continue_statement:a
            {: RESULT = a; :}
    |   return_statement:a
            {: RESULT = a; :}
    |   synchronized_statement:a
            {: RESULT = a; :}
    |   throw_statement:a
            {: RESULT = a; :}
    |   try_statement:a
            {: RESULT = a; :}
    |   assert_statement:a
            {: RESULT = a; :}
    ;
empty_statement ::=
                    // Empty
        SEMICOLON:a
            {: RESULT = parser.nf.Empty(parser.pos(a)); :}
    ;
labeled_statement ::=
                    // Labeled
        IDENTIFIER:a COLON statement:b
            {: RESULT = parser.nf.Labeled(parser.pos(a, b),
                                      a.getIdentifier(), b); :}
    ;
labeled_statement_no_short_if ::=
                    // Labeled
        IDENTIFIER:a COLON statement_no_short_if:b
            {: RESULT = parser.nf.Labeled(parser.pos(a, b),
                                      a.getIdentifier(), b); :}
    ;
expression_statement ::=
                    // Stmt
        statement_expression:a SEMICOLON:d
            {: RESULT = parser.nf.Eval(parser.pos(a, d), a); :}
    ;
statement_expression ::=
                    // Expr
        assignment:a
            {: RESULT = a; :}
    |   preincrement_expression:a
            {: RESULT = a; :}
    |   predecrement_expression:a
            {: RESULT = a; :}
    |   postincrement_expression:a
            {: RESULT = a; :}
    |   postdecrement_expression:a
            {: RESULT = a; :}
    |   method_invocation:a
            {: RESULT = a; :}
    |   class_instance_creation_expression:a
            {: RESULT = a; :}
    ;
if_then_statement ::=
                    // If
        IF:n LPAREN expression:a RPAREN statement:b
            {: RESULT = parser.nf.If(parser.pos(n, b), a, b); :}
    ;
if_then_else_statement ::=
                    // If
        IF:n LPAREN expression:a RPAREN statement_no_short_if:b 
            ELSE statement:c
            {: RESULT = parser.nf.If(parser.pos(n, c), a, b, c); :}
    ;
if_then_else_statement_no_short_if ::=
                    // If
        IF:n LPAREN expression:a RPAREN statement_no_short_if:b
            ELSE statement_no_short_if:c
            {: RESULT = parser.nf.If(parser.pos(n, c), a, b, c); :}
    ;
switch_statement ::=
                    // Switch
        SWITCH:n LPAREN expression:a RPAREN switch_block:b
            {: RESULT = parser.nf.Switch(parser.pos(n, b), a, b); :}
    ;
switch_block ::=
                    // List of SwitchElement
        LBRACE switch_block_statement_groups:a switch_labels:b RBRACE
            {: RESULT = a;
               a.addAll(b); :}
    |   LBRACE switch_block_statement_groups:a RBRACE
            {: RESULT = a; :}
    |   LBRACE switch_labels:a RBRACE
            {: RESULT = a; :}
    |   LBRACE RBRACE
            {: RESULT = new TypedList(new LinkedList(), SwitchElement.class, false); :}
    ;
switch_block_statement_groups ::=
                    // List of SwitchElement
        switch_block_statement_group:a
            {: RESULT = a; :}        
    |   switch_block_statement_groups:a switch_block_statement_group:b
            {: RESULT = a;
               a.addAll(b); :}
    ;
switch_block_statement_group ::=
                    // List of SwitchElement
        switch_labels:a block_statements:b
            {: List l = new TypedList(new LinkedList(), SwitchElement.class, false);
               l.addAll(a); 
               l.add(parser.nf.SwitchBlock(parser.pos(a, b), b));
               RESULT = l; :}
    ;
switch_labels ::=
                    // List of Case
        switch_label:a
            {: List l = new TypedList(new LinkedList(), Case.class, false);
               l.add(a);
               RESULT = l; :}
    |   switch_labels:a switch_label:b
            {: RESULT = a;
               a.add(b); :}
    ;
switch_label ::=
                    // Case
        CASE:n constant_expression:a COLON:d
            {: RESULT = parser.nf.Case(parser.pos(n, d), a); :}
    |   DEFAULT:n COLON:d
            {: RESULT = parser.nf.Default(parser.pos(n, d)); :}
    ;

while_statement ::=
                    // While
        WHILE:n LPAREN expression:a RPAREN statement:b
            {: RESULT = parser.nf.While(parser.pos(n, b), a, b); :}
    ;
while_statement_no_short_if ::=
                    // While
        WHILE:n LPAREN expression:a RPAREN statement_no_short_if:b
            {: RESULT = parser.nf.While(parser.pos(n, b), a, b); :}
    ;
do_statement ::=            
                    // Do
        DO:n statement:a WHILE LPAREN expression:b RPAREN SEMICOLON:d
            {: RESULT = parser.nf.Do(parser.pos(n, d), a, b); :}
    ;
for_statement ::=
                    // For 
        FOR:n LPAREN for_init_opt:a SEMICOLON expression_opt:b SEMICOLON:e
            for_update_opt:c RPAREN statement:d
            {: RESULT = parser.nf.For(parser.pos(n, e), a, b, c, d); :}
    ;
for_statement_no_short_if ::=
                    // For
        FOR:n LPAREN for_init_opt:a SEMICOLON expression_opt:b SEMICOLON:e
            for_update_opt:c RPAREN statement_no_short_if:d
            {: RESULT = parser.nf.For(parser.pos(n, e), a, b, c, d); :}
    ;
for_init_opt ::=
                    // List of ForInit
            {: RESULT = new TypedList(new LinkedList(), ForInit.class, false); :}
    |   for_init:a
            {: RESULT = a; :}
    ;
for_init ::=
                    // List of ForInit
        statement_expression_list:a
            {: RESULT = a; :}
    |   local_variable_declaration:a
            {: List l = new TypedList(new LinkedList(), ForInit.class, false);
               l.addAll(a);
               RESULT = l; :}
    ;
for_update_opt ::=
                    // List of ForUpdate
            {: RESULT = new TypedList(new LinkedList(), ForUpdate.class, false); :}
    |   for_update:a
            {: RESULT = a; :}
    ;
for_update ::=
                    // List of ForUpdate
        statement_expression_list:a
            {: RESULT = a; :}
    ;
statement_expression_list ::=
                    // List of Stmt
        statement_expression:a
            {: List l = new TypedList(new LinkedList(), Eval.class, false);
               l.add(parser.nf.Eval(parser.pos(a), a));
               RESULT = l; :}
    |   statement_expression_list:a COMMA statement_expression:b
            {: RESULT = a;
               a.add(parser.nf.Eval(parser.pos(a, b), b)); :}
    ;

identifier_opt ::=
                    // Name
            {: RESULT = null; :}
    |   IDENTIFIER:a
            {: RESULT = new Name(parser, parser.pos(a), 
                a.getIdentifier()); :}
    ;

break_statement ::=
                    // Branch
        BREAK:n identifier_opt:a SEMICOLON:d
            {: if (a == null)
                   RESULT = parser.nf.Break(parser.pos(n, d));
               else
                   RESULT = parser.nf.Break(parser.pos(n, d), a.toString()); :}
    ;

continue_statement ::=
                    // Branch
        CONTINUE:n identifier_opt:a SEMICOLON:d
            {: if (a == null)
                   RESULT = parser.nf.Continue(parser.pos(n, d));
               else
                   RESULT = parser.nf.Continue(parser.pos(n, d), a.toString()); :}
    ;
return_statement ::=
                    // Return
        RETURN:n expression_opt:a SEMICOLON:d
            {: RESULT = parser.nf.Return(parser.pos(n, d), a); :}
    ;
throw_statement ::=
                    // Throw
        THROW:n expression:a SEMICOLON:d
            {: RESULT = parser.nf.Throw(parser.pos(n, d), a); :}
    ;
synchronized_statement ::=
                    // Synchronized
        SYNCHRONIZED:n LPAREN expression:a RPAREN block:b
            {: RESULT = parser.nf.Synchronized(parser.pos(n, b), a, b); :}
    ;
try_statement ::=
                    // Try
        TRY:n block:a catches:b
            {: RESULT = parser.nf.Try(parser.pos(n, b), a, b); :}
    |   TRY:n block:a catches_opt:b finally:c
            {: RESULT = parser.nf.Try(parser.pos(n, c), a, b, c); :}
    ;
catches_opt ::=
                    // List of Catch
            {: RESULT = new TypedList(new LinkedList(), Catch.class, false); :}
    |   catches:a
            {: RESULT = a; :}
    ;
catches ::=
                    // List of Catch
        catch_clause:a
            {: List l = new TypedList(new LinkedList(), Catch.class, false);
               l.add(a);
               RESULT = l; :}
    |   catches:a catch_clause:b
            {: RESULT = a;
               a.add(b); :}
    ;
catch_clause ::=
                    // Catch
        CATCH:n LPAREN formal_parameter:a RPAREN block:b
            {: RESULT = parser.nf.Catch(parser.pos(n, b), a, b); :}
    ;
finally ::=
                    // Block
        FINALLY block:a
            {: RESULT = a; :}
    ;

assert_statement ::=
                    // Assert
        ASSERT:x expression:a SEMICOLON:d
                {: RESULT = parser.nf.Assert(parser.pos(x, d), a); :}
    |   ASSERT:x expression:a COLON expression:b SEMICOLON:d
                {: RESULT = parser.nf.Assert(parser.pos(x, d), a, b); :}
    ;

// 19.12) Expressions
primary ::=
                    // Expr
        primary_no_new_array:a
            {: RESULT = a; :}
    |   array_creation_expression:a
            {: RESULT = a; :}
    ;
primary_no_new_array ::=
                    // Expr
        literal:a
            {: RESULT = a; :}
    |   THIS:a
            {: RESULT = parser.nf.This(parser.pos(a)); :}
    |   LPAREN expression:a RPAREN
            {: RESULT = a; :}
    |   class_instance_creation_expression:a
            {: RESULT = a; :}
    |   field_access:a
            {: RESULT = a; :}
    |   method_invocation:a
            {: RESULT = a; :}
    |   array_access:a
            {: RESULT = a; :}
    |   primitive_type:a DOT CLASS:n
            {: RESULT = parser.nf.Field(parser.pos(a, n), a, "class"); :}
    |   VOID:a DOT CLASS:n
            {: RESULT = parser.nf.Field(parser.pos(a, n), 
                parser.nf.CanonicalTypeNode(parser.pos(a),
                parser.ts.Void()), "class"); :}
    |   array_type:a DOT CLASS:n
            {: RESULT = parser.nf.Field(parser.pos(a, n), a, "class"); :}
    |   name:a DOT CLASS:n
            {: RESULT = parser.nf.Field(parser.pos(a, n), a.toType(), "class"); :}
    |   name:a DOT THIS:n
            {: RESULT = parser.nf.This(parser.pos(a, n), a.toType()); :}
    ;
class_instance_creation_expression ::=
                    // Expr
        NEW:n class_type:a LPAREN argument_list_opt:b RPAREN:d
            {: RESULT = parser.nf.New(parser.pos(n, d), a, b); :}
    |   NEW:n class_type:a LPAREN argument_list_opt:b RPAREN class_body:c
            {: RESULT = parser.nf.New(parser.pos(n, c), a, b, c); :}
    |   primary:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN:d
            {: RESULT = parser.nf.New(parser.pos(a, d), a,
				      b.toType(), c); :}
    |   primary:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN class_body:d
            {: RESULT = parser.nf.New(parser.pos(a, d), a,
				      b.toType(), c, d); :}
    |   name:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN:d
            {: RESULT = parser.nf.New(parser.pos(a, d), a.toExpr(),
				      b.toType(), c); :}
    |   name:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN class_body:d
            {: RESULT = parser.nf.New(parser.pos(a, d), a.toExpr(),
				      b.toType(), c, d); :}
    ;
argument_list_opt ::=
                    // List of Expr
            {: RESULT = new TypedList(new LinkedList(), Expr.class, false); :}
    |   argument_list:a
            {: RESULT = a; :}
    ;
argument_list ::=
                    // List of Expr
        expression:a
            {: List l = new TypedList(new LinkedList(), Expr.class, false);
               l.add(a);
               RESULT = l; :}
    |   argument_list:a COMMA expression:b
            {: RESULT = a;
               a.add(b); :}
    ;
array_creation_expression ::=
                    // NewArray
        NEW:n primitive_type:a dim_exprs:b dims_opt:c
            {: RESULT = parser.nf.NewArray(parser.pos(n, b), a, b,
                c.intValue()); :}
    |   NEW:n class_or_interface_type:a dim_exprs:b dims_opt:c
            {: RESULT = parser.nf.NewArray(parser.pos(n, b), a, b, 
                c.intValue()); :}
    |   NEW:n primitive_type:a dims:b array_initializer:c
            {: RESULT = parser.nf.NewArray(parser.pos(n, c), a,
                b.intValue(), c); :}
    |   NEW:n class_or_interface_type:a dims:b array_initializer:c
            {: RESULT = parser.nf.NewArray(parser.pos(n, c), a,
                b.intValue(), c); :}
    ;
dim_exprs ::=
                    // List of Expr
        dim_expr:a
            {: List l = new TypedList(new LinkedList(), Expr.class, false);
               l.add(a);
               RESULT = l; :}
    |   dim_exprs:a dim_expr:b
            {: RESULT = a;
               a.add(b); :}
    ;
dim_expr ::=
                    // Expr
        LBRACK expression:a RBRACK
            {: RESULT = a; :}
    ;
dims_opt ::=
                    // Integer
            {: RESULT = new Integer(0); :}
    |   dims:a
            {: RESULT = a; :}
    ;
dims ::=
                    // Integer
        LBRACK RBRACK
            {: RESULT = new Integer(1); :}
    |   dims:a LBRACK RBRACK
            {: RESULT = new Integer(a.intValue() + 1); :}
    ;
field_access ::=
                    // Field
        primary:a DOT IDENTIFIER:b
            {: RESULT = parser.nf.Field(parser.pos(a, b), a,
                b.getIdentifier()); :}
    |   SUPER:n DOT IDENTIFIER:a
            {: RESULT = parser.nf.Field(parser.pos(a),
                parser.nf.Super(parser.pos(n)),
                a.getIdentifier()); :}
    |   name:a DOT SUPER:n DOT IDENTIFIER:b
            {: RESULT = parser.nf.Field(parser.pos(b),
                parser.nf.Super(parser.pos(n), a.toType()),
                b.getIdentifier()); :}
    ;
method_invocation ::=
                    // Call
        name:a LPAREN argument_list_opt:b RPAREN:d
            {: RESULT = parser.nf.Call(parser.pos(a, d),
                a.prefix == null ? null : a.prefix.toReceiver(),
                a.name, b); :}
    |   primary:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN:d
            {: RESULT = parser.nf.Call(parser.pos(b, d), a,
                b.getIdentifier(), c); :}
    |   SUPER:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN:d
            {: RESULT = parser.nf.Call(parser.pos(b, d),
                parser.nf.Super(parser.pos(a)),
                b.getIdentifier(), c); :}
    |   name:a DOT SUPER:n DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN:d
            {: RESULT = parser.nf.Call(parser.pos(b, d),
                parser.nf.Super(parser.pos(n), a.toType()),
                b.getIdentifier(), c); :}
    ;
array_access ::=
                    // ArrayAccess
        name:a LBRACK expression:b RBRACK:d
            {: RESULT = parser.nf.ArrayAccess(parser.pos(a, d), a.toExpr(), b); :}
    |   primary_no_new_array:a LBRACK expression:b RBRACK:d
            {: RESULT = parser.nf.ArrayAccess(parser.pos(a, d), a, b); :}
    ;
postfix_expression ::=
                    // Expr
        primary:a
            {: RESULT = a; :}
    |   name:a
            {: RESULT = a.toExpr(); :}
    |   postincrement_expression:a
            {: RESULT = a; :}
    |   postdecrement_expression:a
            {: RESULT = a; :}
    ;
postincrement_expression ::=
                    // Unary
        postfix_expression:a PLUSPLUS:b
            {: RESULT = parser.nf.Unary(parser.pos(a,b), a, Unary.POST_INC); :}
    ;    
postdecrement_expression ::=
                    // Unary
        postfix_expression:a MINUSMINUS:b
            {: RESULT = parser.nf.Unary(parser.pos(a,b), a, Unary.POST_DEC); :}
    ;
unary_expression ::=
                    // Expr
        preincrement_expression:a
            {: RESULT = a; :}
    |   predecrement_expression:a
            {: RESULT = a; :}
    |   PLUS:b unary_expression:a
            {: RESULT = parser.nf.Unary(parser.pos(b,a), Unary.POS, a); :}
    |   MINUS:b unary_expression:a
            {: RESULT = parser.nf.Unary(parser.pos(b,a), Unary.NEG, a); :}
    |   unary_expression_not_plus_minus:a
            {: RESULT = a; :}
    ;
preincrement_expression ::=
                    // Unary
        PLUSPLUS:b unary_expression:a
            {: RESULT = parser.nf.Unary(parser.pos(b,a), Unary.PRE_INC, a); :}
    ;
predecrement_expression ::=
                    // Unary
        MINUSMINUS:b unary_expression:a
            {: RESULT = parser.nf.Unary(parser.pos(b,a), Unary.PRE_DEC, a); :}
    ;
unary_expression_not_plus_minus ::=
                    // Expr
        postfix_expression:a
            {: RESULT = a; :}
    |   COMP:b unary_expression:a
            {: RESULT = parser.nf.Unary(parser.pos(b,a), Unary.BIT_NOT, a); :}
    |   NOT:b unary_expression:a
            {: RESULT = parser.nf.Unary(parser.pos(b,a), Unary.NOT, a); :}
    |   cast_expression:a
            {: RESULT = a; :}
    ;
cast_expression ::=
                    // Cast
        LPAREN primitive_type:a dims_opt:b RPAREN unary_expression:c
            {: RESULT = parser.nf.Cast(parser.pos(a, c),
                parser.array(a, b.intValue()), c); :}
    |   LPAREN expression:a RPAREN unary_expression_not_plus_minus:b
            {: RESULT = parser.nf.Cast(parser.pos(a, b),
                parser.exprToType(a), b); :}
    |   LPAREN name:a dims:b RPAREN unary_expression_not_plus_minus:c
            {: RESULT = parser.nf.Cast(parser.pos(a, c),
                parser.array(a.toType(), b.intValue()), c); :}
    ;
multiplicative_expression ::=
                    // Expr
        unary_expression:a
            {: RESULT = a; :}
    |   multiplicative_expression:a MULT unary_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.MUL, b); :}
    |   multiplicative_expression:a DIV unary_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.DIV, b); :}
    |   multiplicative_expression:a MOD unary_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.MOD, b); :}
    ;
additive_expression ::=
                    // Expr
        multiplicative_expression:a
            {: RESULT = a; :}
    |   additive_expression:a PLUS multiplicative_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.ADD, b); :}
    |   additive_expression:a MINUS multiplicative_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.SUB, b); :}
    ;
shift_expression ::=
                    // Expr
        additive_expression:a
            {: RESULT = a; :}
    |   shift_expression:a LSHIFT additive_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.SHL, b); :}
    |   shift_expression:a RSHIFT additive_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.SHR, b); :}
    |   shift_expression:a URSHIFT additive_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.USHR, b); :}
    ;
relational_expression ::=
                    // Expr
        shift_expression:a
            {: RESULT = a; :}
    |   relational_expression:a LT shift_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.LT, b); :}
    |   relational_expression:a GT shift_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.GT, b); :}
    |   relational_expression:a LTEQ shift_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.LE, b); :}
    |   relational_expression:a GTEQ shift_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.GE, b); :}
    |   relational_expression:a INSTANCEOF reference_type:b
            {: RESULT = parser.nf.Instanceof(parser.pos(a, b), a, b); :}
    ;
    
equality_expression ::=
                    // Expr
        relational_expression:a
            {: RESULT = a; :}
    |   equality_expression:a EQEQ relational_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.EQ, b); :}
    |   equality_expression:a NOTEQ relational_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.NE, b); :}
    ;
and_expression ::=
                    // Expr
        equality_expression:a
            {: RESULT = a; :}
    |   and_expression:a AND equality_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.BIT_AND, b); :}
    ;
exclusive_or_expression ::=
                    // Expr
        and_expression:a
            {: RESULT = a; :}
    |   exclusive_or_expression:a XOR and_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.BIT_XOR, b); :}
    ;
inclusive_or_expression ::=
                    // Expr
        exclusive_or_expression:a
            {: RESULT = a; :}
    |   inclusive_or_expression:a OR exclusive_or_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.BIT_OR, b); :}
    ;
conditional_and_expression ::=
                    // Expr
        inclusive_or_expression:a
            {: RESULT = a; :}
    |   conditional_and_expression:a ANDAND inclusive_or_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.COND_AND, b); :}
    ;
conditional_or_expression ::=
                    // Expr
        conditional_and_expression:a
            {: RESULT = a; :}
    |   conditional_or_expression:a OROR conditional_and_expression:b
            {: RESULT = parser.nf.Binary(parser.pos(a, b), a, 
                Binary.COND_OR, b); :}
    ;
conditional_expression ::=
                    // Expr
        conditional_or_expression:a
            {: RESULT = a; :}
    |   conditional_or_expression:a QUESTION expression:b 
            COLON conditional_expression:c
            {: RESULT = parser.nf.Conditional(parser.pos(a, c), a, 
                b, c); :}
    ;
assignment_expression ::=
                    // Expr
        conditional_expression:a
            {: RESULT = a; :}
    |   assignment:a
            {: RESULT = a; :}
    ;
assignment ::=
                    // Expr
        left_hand_side:a assignment_operator:b assignment_expression:c
            {: RESULT = parser.nf.Assign(parser.pos(a, c), a, b, c); :}
    ;
left_hand_side ::=
                    // Expr
        name:a
            {: RESULT = a.toExpr(); :}
    |   field_access:a
            {: RESULT = a; :}
    |   array_access:a
            {: RESULT = a; :}
    ;
assignment_operator ::=
                    // Assign.Operator
        EQ
            {: RESULT = Assign.ASSIGN; :}
    |   MULTEQ
            {: RESULT = Assign.MUL_ASSIGN; :}
    |   DIVEQ
            {: RESULT = Assign.DIV_ASSIGN; :}
    |   MODEQ
            {: RESULT = Assign.MOD_ASSIGN; :}
    |   PLUSEQ
            {: RESULT = Assign.ADD_ASSIGN; :}
    |   MINUSEQ
            {: RESULT = Assign.SUB_ASSIGN; :}
    |   LSHIFTEQ
            {: RESULT = Assign.SHL_ASSIGN; :}
    |   RSHIFTEQ
            {: RESULT = Assign.SHR_ASSIGN; :}
    |   URSHIFTEQ
            {: RESULT = Assign.USHR_ASSIGN; :}
    |   ANDEQ
            {: RESULT = Assign.BIT_AND_ASSIGN; :}
    |   XOREQ
            {: RESULT = Assign.BIT_XOR_ASSIGN; :}
    |   OREQ
            {: RESULT = Assign.BIT_OR_ASSIGN; :}
    ;
expression_opt ::=
                    // Expr
            {: RESULT = null; :}
    |   expression:a
            {: RESULT = a; :}
    ;
expression ::=
                    // Expr
        assignment_expression:a
            {: RESULT = a; :}
    ;
constant_expression ::=
                    // Expr
        expression:a
            {: RESULT = a; :}
;
