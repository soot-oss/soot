/* Soot - a J*va Optimization Framework
 * Copyright (C) 2004 Ondrej Lhotak
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

package soot.jimple.paddle;
import soot.*;
import soot.jimple.*;
import soot.jimple.paddle.queue.*;
import soot.jimple.paddle.bdddomains.*;
import java.util.*;

/** Analysis for AspectJ cflow optimization.
 * @author Ondrej Lhotak
 */
public class BDDCflow
{ 
    public static final boolean DEBUG = false;
    public BDDCflow() {
        stmtMethod = 0B;
        if(DEBUG) G.v().out.println("Getting call graph");
        for( Iterator scIt = Scene.v().getApplicationClasses().iterator(); scIt.hasNext(); ) {
            final SootClass sc = (SootClass) scIt.next();
            for( Iterator mIt = sc.getMethods().iterator(); mIt.hasNext(); ) {
                final SootMethod m = (SootMethod) mIt.next();
                if( m.hasActiveBody() ) {
                    for( Iterator sIt = m.getActiveBody().getUnits().iterator(); sIt.hasNext(); ) {
                        final Stmt s = (Stmt) sIt.next();
                        Scene.v().getUnitNumberer().add(s);
                        stmtMethod |= new{s=>stmt, m=>method};
                    }
                }
            }
        }
        <kind> wantedKinds =
              new{Kind.STATIC=>kind} 
            | new{Kind.VIRTUAL=>kind}
            | new{Kind.INTERFACE=>kind}
            | new{Kind.SPECIAL=>kind}
            | new{Kind.CLINIT=>kind}
            | new{Kind.PRIVILEGED=>kind}
            | new{Kind.NEWINSTANCE=>kind};

        callGraph = (srcc=>, tgtc=>) PaddleScene.v().cg.edges().get(){kind}
                                                       <> wantedKinds{kind};
        if(DEBUG) G.v().out.println("Done getting call graph");
    }
    private <stmt, method> stmtMethod;
    <stmt, method> stmtMethod() { return stmtMethod; }
    private <srcm, stmt, tgtm> callGraph;
    <srcm, stmt, tgtm> callGraph() { return callGraph; }
}
