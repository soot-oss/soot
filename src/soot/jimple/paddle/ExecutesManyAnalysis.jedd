/* Soot - a J*va Optimization Framework
 * Copyright (C) 2004 Ondrej Lhotak
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

package soot.jimple.paddle;
import soot.jimple.paddle.bdddomains.*;
import soot.*;
import java.util.*;
import soot.toolkits.scalar.*;
import soot.toolkits.graph.*;

/** An analysis that finds statements in the program that may execute
 * more than once.
 * @author Ondrej Lhotak
 */
public class ExecutesManyAnalysis extends SceneTransformer
{ 
    public ExecutesManyAnalysis( Singletons.Global g ) {}
    public static ExecutesManyAnalysis v() { return G.v().soot_jimple_paddle_ExecutesManyAnalysis(); }

    public class IntraProc extends ForwardFlowAnalysis {
        public IntraProc(UnitGraph g) {
            super(g);
            doAnalysis();
        }

        protected void copy(Object inO, Object outO) {
            FlowSet in = (FlowSet) inO;
            FlowSet out = (FlowSet) outO;

            in.copy(out);
        }
        // STEP 1: What are we computing?
        // SETS OF STATEMENTS THAT MAY HAVE EXECUTED.
        //
        // STEP 2: Precisely define what we are computing.
        // A statement S may have executed at program point P if there exists
        // a path from the start node to P passing through S.
        //
        // STEP 3: Decide whether it is a backwards or forwards analysis.
        // FORWARDS
        //
        // STEP 4: Is the merge operator union or intersection?
        // UNION

        protected void merge(Object inoutO, Object inO) {
            FlowSet inout = (FlowSet) inoutO;
            FlowSet in = (FlowSet) inO;

            inout.union(in);
        }
        protected void merge(Object in1O, Object in2O, Object outO) {
            FlowSet in1 = (FlowSet) in1O;
            FlowSet in2 = (FlowSet) in2O;
            FlowSet out = (FlowSet) outO;

            in1.union(in2, out);
        }
        // STEP 5: Define flow equations.
        // out(s) = ( in(s) union {s} )
        protected void flowThrough(Object outValue, Object unit, Object inValue) {
            Unit u = (Unit) unit;
            FlowSet in = (FlowSet) inValue;
            FlowSet out = (FlowSet) outValue;
            in.copy(out);
            out.add(u);
        }
        // STEP 6: Determine value for start/end node, and
        // initial approximation.
        //
        // start node:            empty set
        // initial approximation: empty set
        protected Object entryInitialFlow()
        {
            return new ArraySparseSet();
        }
            
        protected Object newInitialFlow()
        {
            return new ArraySparseSet();
        }

        public boolean mayExecuteTwice( Unit u ) {
            return ((FlowSet) getFlowBefore(u)).contains(u);
        }
    }

    protected void internalTransform( String phaseName, Map options ) {
        <ctxt> allContexts = 1B;
        for( Iterator clIt = Scene.v().getApplicationClasses().iterator(); clIt.hasNext(); ) {
            final SootClass cl = (SootClass) clIt.next();
            for( Iterator mIt = cl.getMethods().iterator(); mIt.hasNext(); ) {
                final SootMethod m = (SootMethod) mIt.next();
                if( !m.hasActiveBody() ) continue;
                if( !Results.v().reachableMethods().contains(null, m) ) continue;
                IntraProc intra = new IntraProc(
                        new ExceptionalUnitGraph(m.getActiveBody()));
                for( Iterator sIt = m.getActiveBody().getUnits().iterator(); sIt.hasNext(); ) {
                    final Unit s = (Unit) sIt.next();
                    Scene.v().getUnitNumberer().add(s);
                    stmtMethod |= new{s=>stmt, m=>method};
                    if( intra.mayExecuteTwice(s) ) {
                        twiceUnit |= new{s=>stmt}{} >< allContexts{};
                    }
                }
            }
        }
        callGraph = (kind=>) Results.v().callGraph().edges().get();

        while(true) {
            <ctxt, stmt> oldUnit = twiceUnit;
            <ctxt, method> oldMethod = twiceMethod;
            twiceMethod |=                         twiceUnit{stmt, ctxt} <> 
                (srcm=>, tgtm=>method, tgtc=>ctxt) callGraph{stmt, srcc};
            twiceMethod |=                       twiceMethod{method, ctxt} <>
                (stmt=>, tgtm=>method, tgtc=>ctxt) callGraph{srcm, srcc};
            twiceUnit |= twiceMethod{method} <> stmtMethod{method};
            if( oldUnit == twiceUnit && oldMethod == twiceMethod ) break;
        }
    }

    public boolean executesMany(Unit s) {
        return (ctxt=>) twiceUnit{stmt} >< new{s=>stmt}{stmt} != 0B;
    }
    public boolean executesMany(SootMethod m) {
        return (ctxt=>) twiceMethod{method} >< new{m=>method}{method} != 0B;
    }
    protected <stmt, method> stmtMethod;
    protected <ctxt, stmt> twiceUnit;
    protected <ctxt, method> twiceMethod;
    protected <srcc, srcm, stmt, tgtc, tgtm> callGraph;
}

